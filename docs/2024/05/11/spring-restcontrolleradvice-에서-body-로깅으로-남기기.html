<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[spring] @restcontrolleradvice 에서 body 로깅으로 남기기" /><meta name="author" content="Colin Holzman" /><meta property="og:locale" content="en_US" /><meta name="description" content="2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md" /><meta property="og:description" content="2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md" /><link rel="canonical" href="http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0" /><meta property="og:url" content="http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0" /><meta property="og:site_name" content="김민식 기술블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[spring] @restcontrolleradvice 에서 body 로깅으로 남기기" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Colin Holzman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Colin Holzman"},"dateModified":"2024-05-11T00:00:00+09:00","datePublished":"2024-05-11T00:00:00+09:00","description":"2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md","headline":"[spring] @restcontrolleradvice 에서 body 로깅으로 남기기","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0"},"url":"http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0"}</script><title> [spring] @restcontrolleradvice 에서 body 로깅으로 남기기 - 김민식 기술블로그</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="김민식 기술블로그" href="/atom.xml"><link rel="alternate" type="application/json" title="김민식 기술블로그" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0}body{font-family:-apple-system,BlinkMacSystemFont,"avenir next",avenir,helvetica,"helvetica neue",ubuntu,roboto,noto,"segoe ui",arial,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none;padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:0 auto 2rem auto;padding:1rem}.title{margin:2rem auto 0 auto;max-width:60rem;padding-left:12rem;font-size:24px}.title a{text-decoration:none;font-weight:bold}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.section-nav{background-color:#fff;margin:5px 0;padding:10px 30px;border:1px solid #e8e8e8;border-radius:3px}figcaption{font-size:smaller}.pagination{margin-top:1.5rem;display:flex;align-items:center;gap:1rem;margin-left:auto}.pagination .page_number{margin-right:1rem}.pagination .page_number .current{font-weight:bold}.pagination img{width:24px;height:24px;display:block;padding:4px}.pagination img.disabled{opacity:.3}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-150864545-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-150864545-1'); </script></head><body><div class="title"> <a href="/">김민식 기술블로그</a></div><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Posts</a></li><li><a href="/about" >About</a></li><li><a href="/resume" >Resume</a></li><li><a href="/search" >Search</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>[spring] @restcontrolleradvice 에서 body 로깅으로 남기기</h2><div class="toc"><ol id="toc" class="section-nav"><li class="toc-entry toc-h1"><a href="#20240511-----restcontrolleradvice-에서-body-로깅으로-남기기md">2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md</a><ol><li class="toc-entry toc-h2"><a href="#사건의-발단">사건의 발단</a></li><li class="toc-entry toc-h2"><a href="#httpservletrequest-에서-값을-읽을-때는-내부적으로-inputstream-을-사용한다">HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.</a></li><li class="toc-entry toc-h2"><a href="#contentcachingrequestwrapper">ContentCachingRequestWrapper</a></li><li class="toc-entry toc-h2"><a href="#적용">적용</a><ol><li class="toc-entry toc-h3"><a href="#참고">참고</a></li></ol></li></ol></li></ol></div><div class="content"><h1 id="20240511-----restcontrolleradvice-에서-body-로깅으로-남기기md">2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md</h1><h2 id="사건의-발단">사건의 발단</h2><p>현재 진행하고 있는 프로젝트에서는 @RestControllerAdvice 를 이용하여 예외를 전역으로 처리하고 있다.<br /> 예외가 났을 때 어떤 요청값이 들어와서 예외가 발생했는 지 로그로 남기고 싶어서 request 의 body 를 읽고 싶었으나 아무런 값이 없는 문제가 발생했다.</p><pre><code class="language-java">
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(HotelkingException.class)
  public ResponseEntity&lt;ApiResponse&lt;ErrorContent&gt;&gt; handleHotelkingException(
      HotelkingException e,
      HttpServletRequest request
  ){
    ErrorCode ec = e.getErrorCode();
String body = StreamUtils.copyToString(request.getInputStream(), StandardCharsets.UTF_8);
log.error("body = {}", body); // 슬프게도 아무것도 안나온다.
    return ResponseEntity.status(ec.getHttpStatus()).body(ApiResponse.error(ErrorContent.from(ec)));
  }

  @ExceptionHandler(HttpMessageNotReadableException.class)
  public ResponseEntity&lt;ApiResponse&lt;ErrorContent&gt;&gt; handleHttpMessageNotReadableException(HttpMessageNotReadableException e, HttpServletRequest request) {
    ErrorCode ec = ErrorCode.NOT_READABLE;
    printLog(request, ec);
    return ResponseEntity
        .status(ErrorCode.NOT_READABLE.getHttpStatus())
        .body(ApiResponse.error(ErrorContent.from(ec)));
  }

}
</code></pre><p>HttpServletRequest 에서 다시 한번 InputStream 을 이용하여 body 를 읽으려고 했지만 아무것도 읽을 수 없었다.</p><h2 id="httpservletrequest-에서-값을-읽을-때는-내부적으로-inputstream-을-사용한다">HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.</h2><blockquote><p>The spring-web module contains the HttpMessageConverter interface for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for concurrency, in the RestClient) and on the server side (for concurrency, in Spring MVC REST controllers).</p></blockquote><p><img src="https://velog.velcdn.com/images/kmss6905/post/bc215933-2cc6-43a4-9a7f-36dc13766dee/image.png" alt="" /></p><p>Spring MVC 는 Servlet API 기반으로 만들어졌다. Spring MVC 에서는 Dispatcher Servlet 이 그 역할을 담당하고 있다. Http 요청을 다룰 때 HttpServletRequest 에서 요청 body 를 읽을 때 <code>getInputStream()</code> 그리고 <code>getReader()</code> 메서드를 제공한다. 이러한 각 메소드는 동일한 InputStream 을 사용하기 때문에 InputStream을 한 번 읽으면 다시 읽을 수 없는 문제가 있다.</p><h2 id="contentcachingrequestwrapper">ContentCachingRequestWrapper</h2><p><code>ContentCachingRequestWrapper</code> 는 생성자로 받은 HttpServeltRequest 를 input stream 과 reader 로 부터 모든 HttpServletRequest 컨텐츠를 캐시하는 HttpServlerRequest Wrapper 클래스이다.</p><p>캐시한 content 는 byte array 형태로 다시 얻을 수 있다.</p><p>얻을 때는 <code>getContentAsByteArray()</code> 를 통해 다시 얻을 수 있다.</p><p>중요한 건 요청 컨텐츠가 consumed 되지 않았다면, 컨텐츠는 캐시되지 않는다.</p><pre><code class="language-java">
public class ContentCachingRequestWrapper extends HttpServletRequestWrapper {

private final FastByteArrayOutputStream cachedContent;

public ContentCachingRequestWrapper(HttpServletRequest request) {
		super(request);
		
		// 캐시 하는 부분
		int contentLength = request.getContentLength();
		
		// content 가 있는 경우 캐시한다.
		this.cachedContent = (contentLength &gt; 0) ? new FastByteArrayOutputStream(contentLength) : new FastByteArrayOutputStream();
		this.contentCacheLimit = null;
	}
	
	...
	
	// 캐시한 컨텐츠를 가져온다.
	public byte[] getContentAsByteArray() {
		return this.cachedContent.toByteArray();
	}
}
</code></pre><p>엄청 특이한 건 없다.</p><p>다만 <code>FastByteArrayOutputStream</code> 이라고 하는 OutputStream 을 extend 하여 새롭게 만들어 사용하고 있다. 문서에서는 ByteArrayOutputStream 의 대안으로 나왔다고 한다.</p><p>참고로 <code>AbstractRequestLoggingFilter</code> 에서도 위의 <code>ContentCachingRequestWrapper</code> 가 사용된다.</p><p><img src="https://velog.velcdn.com/images/kmss6905/post/8eb4fafc-4f37-4855-9bb4-8a8bc838a0d5/image.png" alt="" /></p><h2 id="적용">적용</h2><p>Custom Filter 를 만들어 기존 HttpServletRequest 를 캐싱할 수 있도록 들어온 HttpServletRequest 를 이용하여 ContentCachingRequestWrapper 객체를 만든 후 doFilter를 호출합니다.</p><pre><code class="language-java">@Component
public class CachingFilter extends OncePerRequestFilter {

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {
    filterChain.doFilter(new ContentCachingRequestWrapper(request), response);
  }
}
</code></pre><h3 id="참고">참고</h3><ul><li>https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-message-conversion</li></ul></div><span class="meta"><time datetime="2024-05-11T00:00:00+09:00">May 11, 2024</time> &middot; </span> <script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script></section></main></body></html>
