<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="다시 깨닫는 영속성 컨텍스트의 중요성" /><meta name="author" content="Colin Holzman" /><meta property="og:locale" content="en_US" /><meta name="description" content="2024.11.10 - 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨 중요성" /><meta property="og:description" content="2024.11.10 - 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨 중요성" /><link rel="canonical" href="http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1" /><meta property="og:url" content="http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1" /><meta property="og:site_name" content="김민식 기술블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-02-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="다시 깨닫는 영속성 컨텍스트의 중요성" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Colin Holzman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Colin Holzman"},"dateModified":"2024-02-21T00:00:00+09:00","datePublished":"2024-02-21T00:00:00+09:00","description":"2024.11.10 - 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨 중요성","headline":"다시 깨닫는 영속성 컨텍스트의 중요성","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1"},"url":"http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1"}</script><title> 다시 깨닫는 영속성 컨텍스트의 중요성 - 김민식 기술블로그</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="김민식 기술블로그" href="/atom.xml"><link rel="alternate" type="application/json" title="김민식 기술블로그" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0}body{font-family:-apple-system,BlinkMacSystemFont,"avenir next",avenir,helvetica,"helvetica neue",ubuntu,roboto,noto,"segoe ui",arial,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none;padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:0 auto 2rem auto;padding:1rem}.title{margin:2rem auto 0 auto;max-width:60rem;padding-left:12rem;font-size:24px}.title a{text-decoration:none;font-weight:bold}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.section-nav{background-color:#fff;margin:5px 0;padding:10px 30px;border:1px solid #e8e8e8;border-radius:3px}figcaption{font-size:smaller}.pagination{margin-top:1.5rem;display:flex;align-items:center;gap:1rem;margin-left:auto}.pagination .page_number{margin-right:1rem}.pagination .page_number .current{font-weight:bold}.pagination img{width:24px;height:24px;display:block;padding:4px}.pagination img.disabled{opacity:.3}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-150864545-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-150864545-1'); </script></head><body><div class="title"> <a href="/">김민식 기술블로그</a></div><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Posts</a></li><li><a href="/about" >About</a></li><li><a href="/resume" >Resume</a></li><li><a href="/search" >Search</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>다시 깨닫는 영속성 컨텍스트의 중요성</h2><div class="toc"><ol id="toc" class="section-nav"><li class="toc-entry toc-h1"><a href="#20241110---다시금-깨닫는-영속성-컨텍스트와-db-격리-레벨-중요성">2024.11.10 - 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨 중요성</a><ol><li class="toc-entry toc-h3"><a href="#원인-분석-과-해결-과정">원인 분석 과 해결 과정</a><ol><li class="toc-entry toc-h4"><a href="#수정된-코드">수정된 코드</a></li></ol></li><li class="toc-entry toc-h3"><a href="#해결">해결</a></li></ol></li></ol></div><div class="content"><h1 id="20241110---다시금-깨닫는-영속성-컨텍스트와-db-격리-레벨-중요성">2024.11.10 - 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨 중요성</h1><blockquote><p>Lock 과 관련한 간단한 코드를 작성하고 테스트를 실했을 때 원치않은 결과가 계속 나오는 것을 보고 도대체 잘못된 결과가 나온 것일까? 결론부터 말하자면</p><ol><li><strong>영속성 컨텍스트를 생각하지 않았던 것</strong></li><li><strong>Lock 의 범위 설정을 잘하지 못한 것</strong></li><li><strong>(사실 가장 중요하다) MySQL 의 InnoDB 엔진 기본 Isolation Level 을 고려하지 않을 것</strong></li></ol></blockquote><p><img src="images/persistence_context.png" alt="스크린샷 2024-11-22 오후 1.31.37.png" /></p><p>https://www.baeldung.com/jpa-hibernate-persistence-context</p><h3 id="원인-분석-과-해결-과정">원인 분석 과 해결 과정</h3><p>만약 Lock 을 10초 동안 기다려서 획득했을 때의 roomStock 은 새롭게 BD 에서 값이 갱신된 roomStock 정보가 아닌 앞에서 조회했던 객체 즉, 영속성 컨텍스트에 있던 객체이다. 따라서 최악의 경우에는 아래와 같이 동작한다.</p><p>즉, Lock 을 흭득하는 것은 좋았으나, 문제는 JPA 의 업데이트 하려고 하는 roomStock 데이터는 영속성 컨텍스트에서 조회하기 때문에 다른 스레드가 roomStock 의 count 를 업데이트 해서 값이 변경 되었지만, 영속성 컨텍스트에서 데이터를 가져와서 갱신하기 때문에 데이터 불일치가 발생한다.</p><h4 id="수정된-코드">수정된 코드</h4><p>여전히 문제가 많습니다..</p><pre><code class="language-java">
@Transactional
  public String reserve(long roomId) {
    try {
      Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1);
      if (lock == null || lock == 0) {
        log.info("lock 획득 실패");
        return "fail";
      }
      log.info("acquire Lock !");
      RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow();
      roomStock.decrease();
    } catch (RuntimeException e) {
      log.warn(e.getMessage());
    } finally {
      roomStockRepository.releaseLock(String.valueOf(roomId));
      log.info("release Lock !");
    }
      return "success";
  }

</code></pre><p>위의 코드는 실행이 잘 될까? 결론부터 말하자면 이 역시 제대로 동작하지 않는다.</p><p>동작하지 않은 이유 추측 1 : lock 을 해제 한 후 commit 하기 전(즉, flush 가 일어나서 실제로 db에 반영되기 전)에 다른 thread 가 lock 을 획득하는 경우 commit 이전에 다른 스레드가 lock 을 획득하고 findRoomStockByRoomId 을 통해 RoomStock 을 가져온다면 이론상 가능하다. 하지만 테스트한 환경에서는 그러한 상황이 연출되지 않았다.</p><p>MySQL general_log 를 활성한 후, tx 별 로그를 살펴봐도 위와 같은 상황은 연출되지 않았음에도 불구하고 원하는 결과가 나오지 않았다. 박스로 표시된 부분이 문제가 되는 부분이다. <img src="images/img.png" alt="general_log" /></p><p>MySQL 의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준은 REPEATABLE READ 이다. 1961 tx 가 먼저 commit 을 한 이후 1962 tx 가 조회하고 update 했을 때 바로 commit 이후에 변경된 값이 아닌 저장된 스냅샷으로 부터 데이터를 조회하게 된다.</p><h3 id="해결">해결</h3><ol><li>이를 해결하기 위해 Lock 획득을 먼저 한 후 RoomStock 을 조회를 할 수 있도록 코드를 변경해야한다.(사실 애초에 이렇게 작성했다면 문제가 없었을 까?.)</li><li>MySQL 엔진을 InnoDB 로 사용하는 경우 기본 래벨은 REPEATABLE READ 이다. 이 격리 수준에서는 트랜잭션 시작 시점에 생성된 스냅샷을 기준으로 데이터를 읽기 때문에 실제 제고를 SELECT 하고 감소할 때는 @Transactional(propagation = Propagation.REQUIRES_NEW) 이용하여 새로운 트랜잭션을 시작, 스냅샷으로 부터 데이터를 조회하지 않도록 하는 방법을 사용할 수 있다. ```java</li></ol><p>@Service @Slf4j public class ReservationService {</p><p>private final RoomStockRepository roomStockRepository; private final RoomStockService roomStockService;</p><p>public ReservationService(RoomStockRepository roomStockRepository, RoomStockService roomStockService) { this.paymentApi = paymentApi; this.roomStockRepository = roomStockRepository; this.roomStockService = roomStockService; }</p><p>// 증명하고자 하는 것 // =&gt; thread x 가 release 하고 나서 flush 하기 전에 thread y 가 lock 획득하고 room_stock 을 조회해서 잘못된 데이터를 가져오지 않았을 까? @Transactional public String reserve(long roomId) { try { Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1); if (lock == null || lock == 0) { log.info(“lock 획득 실패”); return “fail”; } log.info(“acquire Lock !”); roomStockService.decrease(roomId); } catch (RuntimeException e) { log.warn(e.getMessage()); } finally { Long aLong = roomStockRepository.releaseLock(String.valueOf(roomId)); log.info(“release Lock ! : {}”, aLong == 1); } return “success”; } }</p><p>@Slf4j @Service public class RoomStockService {</p><p>private final RoomStockRepository roomStockRepository;</p><p>public RoomStockService(RoomStockRepository roomStockRepository) { this.roomStockRepository = roomStockRepository; }</p><p>@Transactional(propagation = Propagation.REQUIRES_NEW) public void decrease(long roomId) { try { RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow(); roomStock.decrease(); roomStockRepository.saveAndFlush(roomStock); } catch (RuntimeException e) { log.warn(e.getMessage()); } } }</p><p>```</p><blockquote><p>Transaction 을 길게 잡는 다면 그 만큼 요청당 DB Connection 을 소유하는 시간 역시 길어진다는 소리이고 이는 Connection 풀을 더 빨리 마르게 하는 요인이 될 수 있다. 즉, 빨리 Connection 을 사용하고 DBCP 에 반납해줘야 하는 데 불필요하게 오래 잡고 있다보니 뒤이어 오는 요청들은 Connection 을 얻을 때 까지 기다릴 수 밖에 없게 되기 때문에 요청 응답시간은 더욱 더 길어질 수 밖에 없다.</p></blockquote><blockquote><p>참고로 영속성 컨텍스트는 두 가지 스코프 타입이 존재하는 데</p><ol><li>Transaction-Scoped : 말 그대로, 영속성 컨텍스트가 존재하는 범위가 Transaction 까지 이다. 따라서 트랜잭션이 끝나면 해당 영속성 컨텍스트를 flush 하게 됩니다.</li><li>Extended-Scoped : 여러 트랜잭션에 걸쳐 있을 수 영속성 컨텍스트 로서. 트랜잭션 없이도 엔터티를 지속할 수 있지만 트랜잭션 없이는 flush 할 수 없습니다. 기본적으로 아무 설정을 하지 않는다면 Persistence-Context 의 기본 Scope 는 Transaction-Scoped 이다.<pre><code class="language-java">@Repeatable(PersistenceContexts.class)
@Target({TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface PersistenceContext {

// ...

/**
 * (Optional) Specifies whether a transaction-scoped persistence context 
 * or an extended persistence context is to be used.
 */
PersistenceContextType type() default PersistenceContextType.TRANSACTION;
   
// ...
}
</code></pre></li></ol></blockquote></div><span class="meta"><time datetime="2024-02-21T00:00:00+09:00">February 21, 2024</time> &middot; </span> <script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script></section></main></body></html>
