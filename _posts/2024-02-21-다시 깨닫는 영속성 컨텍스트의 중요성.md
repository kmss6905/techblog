---
layout: post
title: "다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성"
description: "분산락을 이용한 동시성 제어 코드 작성 중 발생한 문제를 통해 영속성 컨텍스트와 DB 격리 레벨의 중요성을 다시 한번 깨달았습니다. 문제 원인 분석과 해결 과정을 공유합니다."
categories:
- "JPA"
- "Spring"
tags:
- "jpa"
- "영속성 컨텍스트"
- "db 격리 레벨"
- "동시성"
- "분산락"
- "spring"
date: "2024-02-21 00:00:00 +0900"
toc: true
---

# 다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성

> 분산락(Distributed Lock) 관련 코드를 작성하고 테스트하던 중, 예상치 못한 결과가 계속 발생했습니다. 원인을 파고들어 보니, 제가 간과하고 있던 중요한 개념들이 있었습니다. 이 글에서는 그 과정에서 얻은 교훈을 공유하고자 합니다.

결론부터 말하자면, 문제의 원인은 다음과 같았습니다.

1.  **영속성 컨텍스트**를 제대로 이해하지 못했던 것
2.  **Lock의 범위**를 잘못 설정했던 것
3.  (가장 중요) MySQL **InnoDB 엔진의 기본 격리 레벨(Isolation Level)**을 고려하지 않았던 것

![영속성 컨텍스트](https://www.baeldung.com/wp-content/uploads/2016/10/Hibernate-Persistence-Context-2.png)

## 원인 분석 및 해결 과정

### 문제 상황: 데이터 불일치

문제의 코드는 다음과 같았습니다. `reserve` 메서드는 `roomId`를 받아 해당 방의 재고(`RoomStock`)를 감소시키는 로직입니다. 동시성 문제를 해결하기 위해 분산락을 사용했습니다.

```java
@Transactional
public String reserve(long roomId) {
    try {
        // 1. 락 획득 시도
        Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1);
        if (lock == null || lock == 0) {
            log.info("락 획득 실패");
            return "fail";
        }
        log.info("락 획득!");

        // 2. 재고 조회 및 감소
        RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow();
        roomStock.decrease();

    } catch (RuntimeException e) {
        log.warn(e.getMessage());
    } finally {
        // 3. 락 해제
        roomStockRepository.releaseLock(String.valueOf(roomId));
        log.info("락 해제!");
    }
    return "success";
}
```

이 코드의 가장 큰 문제는 **영속성 컨텍스트**에 있었습니다. 락을 획득한 후 `findRoomStockByRoomId` 메서드로 `RoomStock` 객체를 조회할 때, JPA는 먼저 영속성 컨텍스트(1차 캐시)를 확인합니다. 만약 이전에 같은 `roomId`로 조회한 `RoomStock` 객체가 영속성 컨텍스트에 존재한다면, **데이터베이스를 다시 조회하지 않고 캐시에 있는 객체를 그대로 반환**합니다.

이로 인해 다른 스레드가 이미 재고를 변경하고 커밋했더라도, 현재 스레드는 변경 전의 데이터를 가지고 `decrease()` 메서드를 호출하게 되어 **데이터 불일치**가 발생합니다.

### 시도 1: 락 해제 시점 변경

처음에는 락을 너무 빨리 해제해서 문제가 발생한다고 생각했습니다. `commit`이 되기 전에 다른 스레드가 락을 획득하고, 아직 변경사항이 반영되지 않은 데이터를 읽어간다고 추측했습니다. 하지만 MySQL의 `general_log`를 확인해 본 결과, 그런 상황은 발생하지 않았습니다.

![MySQL general_log](images/img.png)

### 진짜 원인: REPEATABLE READ 격리 레벨

문제의 핵심은 MySQL InnoDB 스토리지 엔진의 기본 격리 레벨인 **REPEATABLE READ**에 있었습니다. 이 격리 레벨에서는 **트랜잭션이 시작될 때의 데이터 스냅샷**을 만들어, 트랜잭션이 진행되는 동안에는 해당 스냅샷의 데이터만 읽습니다. 따라서 다른 트랜잭션이 데이터를 변경하고 커밋하더라도, 현재 트랜잭션은 그 변경사항을 볼 수 없습니다.

위 로그에서 `1961`번 트랜잭션이 커밋한 이후에 `1962`번 트랜잭션이 데이터를 조회했지만, `1962`번 트랜잭션은 자신이 시작될 때의 스냅샷을 기준으로 데이터를 읽었기 때문에 변경 전의 데이터를 가져온 것입니다.

## 해결 방안

이 문제를 해결하기 위해 다음과 같이 코드를 수정했습니다.

1.  **락 획득 후, 새로운 트랜잭션에서 재고 조회 및 감소 로직 실행**
2.  `@Transactional(propagation = Propagation.REQUIRES_NEW)` 옵션을 사용하여 `decrease` 메서드가 항상 새로운 트랜잭션에서 실행되도록 강제합니다. 이렇게 하면 `decrease` 메서드가 호출될 때마다 새로운 스냅샷을 생성하여 최신 데이터를 읽어올 수 있습니다.

```java
// ReservationService.java
@Service
@Slf4j
public class ReservationService {

    private final RoomStockRepository roomStockRepository;
    private final RoomStockService roomStockService;

    // ... 생성자

    @Transactional
    public String reserve(long roomId) {
        try {
            Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1);
            if (lock == null || lock == 0) {
                log.info("락 획득 실패");
                return "fail";
            }
            log.info("락 획득!");
            // 별도의 트랜잭션을 가진 서비스 메서드 호출
            roomStockService.decrease(roomId);
        } catch (RuntimeException e) {
            log.warn(e.getMessage());
        } finally {
            roomStockRepository.releaseLock(String.valueOf(roomId));
            log.info("락 해제!");
        }
        return "success";
    }
}

// RoomStockService.java
@Slf4j
@Service
public class RoomStockService {

    private final RoomStockRepository roomStockRepository;

    // ... 생성자

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void decrease(long roomId) {
        try {
            RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow();
            roomStock.decrease();
            // 변경사항을 즉시 DB에 반영
            roomStockRepository.saveAndFlush(roomStock);
        } catch (RuntimeException e) {
            log.warn(e.getMessage());
        }
    }
}
```

## 추가 고려사항: 영속성 컨텍스트 스코프

JPA의 영속성 컨텍스트는 기본적으로 **트랜잭션 스코프(Transaction-Scoped)**를 가집니다. 즉, 영속성 컨텍스트의 생명주기는 트랜잭션의 생명주기와 동일합니다. 트랜잭션이 시작될 때 생성되고, 트랜잭션이 끝날 때(커밋 또는 롤백) 사라집니다.

`@PersistenceContext` 어노테이션의 `type` 속성을 통해 **확장 스코프(Extended-Scoped)**를 사용할 수도 있습니다. 확장 스코프는 여러 트랜잭션에 걸쳐 영속성 컨텍스트를 유지할 수 있게 해주지만, 명시적으로 `flush`를 호출해야 변경사항이 반영되므로 주의해서 사용해야 합니다.

```java
@Repeatable(PersistenceContexts.class)
@Target({TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface PersistenceContext {

   // ...

   /**
    * (Optional) Specifies whether a transaction-scoped persistence context 
    * or an extended persistence context is to be used.
    */
   PersistenceContextType type() default PersistenceContextType.TRANSACTION;
   
   // ...
}
```

이번 경험을 통해 동시성 문제를 다룰 때는 코드 로직뿐만 아니라, JPA의 영속성 컨텍스트와 데이터베이스의 격리 레벨까지 깊이 있게 이해하는 것이 얼마나 중요한지 다시 한번 깨닫게 되었습니다.
