---
layout: post
title: "Cookie와 Session을 사용하여 Stateless 극복하기"
description: "HTTP의 Stateless 특성을 극복하기 위한 Cookie와 Session의 개념과 동작 원리를 자세히 알아봅니다. 클라이언트와 서버 간의 상태 유지 방법과 보안 고려사항을 포함합니다."
categories:
- "Web"
tags:
- "cookie"
- "session"
- "http"
- "stateless"
- "web"
- "보안"
date: "2023-08-23 00:00:00 +0900"
toc: true
---

# Cookie와 Session을 사용하여 Stateless 극복하기

HTTP 웹 요청은 기본적으로 상태가 없다. 즉, Stateless 하다.  
가령 로그인 이후에 한 요청한 이후 또 요청을 할 경우, 서버는 요청에 대해서 특별한 처리를 하지 않는 이상 로그인한 유저인지, 혹은 어떤 유저가 요청하고 있는 건지 알 방법이 없다. 그렇기 때문에 서버는 사용자의 로그인을 유지하기 위해 로그인 상태를 기록해야한다. 이를 위해 쿠키와 세션이라는 기술이 등장했다.

## 쿠키(Cookie)

HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 동일한 서버에 재 요청 시 클라이언트 브라우저에 저장된 쿠키와 함께 요청한다. 이를 통해 두 요청이 동일한 브라우저에서 들어왔는 지 판단할 뿐만 아니라 이를 활용하여 로그인 상태유무도 판단할 수 있다.

**서버는 아래와 같은 과정으로 사용자를 식별한다.**

1. 클라이언트가 로그인 시도를 한다.
2. 서버는 로그인에 성공하게 되면 사용자를 식별할 수 있는 '쿠키(Cookie)'를 만들어 HTTP 응답으로 클라이언트에 전달한다.
3. 사용자는 로그인 성공응답으로 받은 '쿠키(Cookie)'를 웹 브라우저 어딘가에 저장 해둔다.
4. 로그인 이후 서버 자원을 요청할 때, 쿠키(Cookie)를 HTTP 요청 헤더에 포함해서 서버에 전달한다.
5. 요청을 받은 서버는 요청 헤더를 살펴본다. 그리고 해당 쿠키에 있는 정보를 바탕으로 유저를 식별, 그에 맞는 응답을 전달한다.

### 클라이언트에 저장되는 쿠키

쿠키는 클라이언트 브라우저에 저장된다. 그렇기 때문에 사용자를 식별할 수 있도록 하는 정보가 계속해서 클라이언트에 남아서는 안된다..따라서 서버에서 쿠키를 생성할 때 직접 만료일 설정하여 해당 만료일이 지난 쿠키값이 요청헤더로 왔을 때 요청을 거부할 수 있도록 하도록 영속쿠키(Persistent Cookie) 를 사용하거나 브라우저 세션이 유지되는 동안만 존재하여, 브라우저가 종료되면 삭제 되는 세션 쿠키(Session Cookie) 를 사용하기도 한다.

참고로 영속쿠키(Persistent Cookie) 의 경우 브라우저 세션이 종료 되어도 남아 있기 때문에 사용자의 기본 설정이나 개인화된 정보를 저장하거나 추적하는 데 사용된다. 반변 세션 쿠키(Session Cookie) 의 경우 브라우저 창이 닫히면 사라지기 때문에 장바구니와 같이 지워지거나 조작되거나 가로 채이더라도 큰 일이 없을 임시 데이터를 저장하는 데 사용된다. 가령 브라우저 종료 시 로그아웃이 되길 바란다면 세션쿠키를 사용하면 된다.

![쿠키와 세션 비교](/assets/images/cookie_session_03.png)

![쿠키 동작 방식](/assets/images/cookie_session_01.png)

### 쿠키와 보안 문제

쿠키는 클라이언트에 저장하는 문제로 인해 여러 보안적인 문제가 있다. 따라서 아래와 같은 방법을 사용한다.

- 쿠키에는 중요한 값을 저장하지 않는다. 탈취되더라도 상관없는 값만 저장한다.
- 사용자 별로 예측 불가능한 임의의 토큰(랜덤값)을 노출하고, 서버에서는 해당 토큰값과 사용자를 매핑해서 인식하도록 한다. 그리고 해당 토큰은 서버에서 관리한다. -> 토큰을 통채로 탈취해서 사용한다면 사용자를 식별할 수 있겠지만, 토큰 조작을 통해 사용자를 유추할 수 없다.
- 토큰을 통채로 탈취하여 사용할 수 있기 때문에 서버에서 토큰을 관리할 때 만료시간을 두어 관리한다. 탈취하여 사용은 할 수 있겠으나 만료가 되어 계속해서 사용할 수 없게 만든다. 또한 해킹이 의심되면 해당 토큰을 서버에서 제거하는 방법도 있다.

## 세션

사용자의 정보를 쿠키에 저장한다. 만약 민감한 정보(신용카드 정보) 나 사용자를 쉽게 유추할 수 있는 정보(memberId=32)를 쿠키에 담게 된다면 심각한 보안상의 위험이 존재한다. 그렇다면 어떻게 해결하면 좋을까? 답은 간단하다. 쿠키에 중요한 정보를 저장하지 않고 전부 서버에 저장하면 된다. 클라이언트는 _추청불가능한 정보_ 라 하는 세션id 를 서버 요청시 함께 전송한다.  
요청 받은 서버는 세션id 와 매핑되어 있는 사용자 정보를 조회하여 사용한다.

**이때 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션 이라고 한다.**

### 세션의 동작방식

![세션 동작 방식](/assets/images/cookie_session_02.png)

1. 클라이언트가 로그인 시도를 해서 사용자가 맞을 경우 서버는 세션을 생성하고 이를 세션저장소에 저장한다. 유저를 지칭할 수 있는 정보와 매칭되는 유일한 랜덤 값의 토큰을 key 지칭되는 유저정보를 value로 하여 세션 저장소에 저장한다.
2. 그리고 서버는 헤더에 토큰 값을 추가하여 응답과 함께 클라이언트에 전달한다.
3. 클라이언트는 쿠키 저장소에 해당 토큰값을 저장한다.
4. 이후 서버에 요청할 때는 쿠키 저장소에 토큰 값을 꺼내 요청헤더(Cookie: sessionId=zzkzidj123) 추가하여 서버로 요청한다.
5. 서버는 요청 헤더에 있는 cookie 값을 통해 세션저장소에 있는 사용자의 정보를 가져오거나 이를 통해 사용자를 식별한다.

## 마치면서

웹 특성 중 하나인 stateless 를 극복하기 위하여 사용자의 상태를 클라이언트가 관리할 수 있도록 '쿠키'를 만들었다. 하지만 쿠키의 경우 클라이언트에만 전적으로 의존하다 보니 사용자의 정보가 탈취되거나 조작될 위험성이 존재한다. 이를 해결하기 위해 쿠키에는 최소한의 정보만을 저장하거나 만료시간을 설정해서 탈취되더라도 사용할 수 없도록 한다. 하지만 최소한의 정보, 위험하다. 따라서 더 나아가 모든 사용자의 정보를 클라이언트가 아닌 서버에 저장하여 사용자의 연결을 유지(관리)할 수 있도록 하는 방법인 세션이 등장했다. 서버는 임의의 토큰값을 키, 매칭되는 유저의 정보를 값으로 하는 세션 저장소를 만들어 유저의 로그인 요청이 오면 해당 유저 정보를 찾을 수 있도록 하는 임의의 토큰값을 생성하여 클라이언트에 전달한다. 클라이언트는 아무런 정보를 유추할 수 없는 임의의 토큰값을 매번 서버에 자원을 요청할 때 헤더에 추가하여 전달하게 된다.
