<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[Spring] @RestControllerAdvice에서 body 로깅으로 남기기" /><meta name="author" content="김민식" /><meta property="og:locale" content="en_US" /><meta name="description" content="@RestControllerAdvice에서 예외 발생 시 HttpServletRequest의 body를 로깅하려 할 때 발생하는 문제를 다룹니다. InputStream이 한 번만 읽을 수 있는 이유를 설명하고, ContentCachingRequestWrapper와 커스텀 필터를 사용하여 이 문제를 해결하는 방법을 제시합니다." /><meta property="og:description" content="@RestControllerAdvice에서 예외 발생 시 HttpServletRequest의 body를 로깅하려 할 때 발생하는 문제를 다룹니다. InputStream이 한 번만 읽을 수 있는 이유를 설명하고, ContentCachingRequestWrapper와 커스텀 필터를 사용하여 이 문제를 해결하는 방법을 제시합니다." /><link rel="canonical" href="http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0" /><meta property="og:url" content="http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0" /><meta property="og:site_name" content="김민식 기술블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Spring] @RestControllerAdvice에서 body 로깅으로 남기기" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"김민식","url":"https://minshikkim.com"},"dateModified":"2024-05-11T00:00:00+09:00","datePublished":"2024-05-11T00:00:00+09:00","description":"@RestControllerAdvice에서 예외 발생 시 HttpServletRequest의 body를 로깅하려 할 때 발생하는 문제를 다룹니다. InputStream이 한 번만 읽을 수 있는 이유를 설명하고, ContentCachingRequestWrapper와 커스텀 필터를 사용하여 이 문제를 해결하는 방법을 제시합니다.","headline":"[Spring] @RestControllerAdvice에서 body 로깅으로 남기기","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0"},"url":"http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0"}</script><title> [Spring] @RestControllerAdvice에서 body 로깅으로 남기기 - 김민식 기술블로그</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="김민식 기술블로그" href="/atom.xml"><link rel="alternate" type="application/json" title="김민식 기술블로그" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> .highlight table td{padding:5px}.highlight table pre{margin:0}.highlight,.highlight .w{color:#24292f;background-color:#f6f8fa}.highlight .k,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .kv{color:#cf222e}.highlight .gr{color:#f6f8fa}.highlight .gd{color:#82071e;background-color:#ffebe9}.highlight .nb{color:#953800}.highlight .nc{color:#953800}.highlight .no{color:#953800}.highlight .nn{color:#953800}.highlight .sr{color:#116329}.highlight .na{color:#116329}.highlight .nt{color:#116329}.highlight .gi{color:#116329;background-color:#dafbe1}.highlight .ges{font-weight:bold;font-style:italic}.highlight .kc{color:#0550ae}.highlight .l,.highlight .ld,.highlight .m,.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .il,.highlight .mo,.highlight .mx{color:#0550ae}.highlight .sb{color:#0550ae}.highlight .bp{color:#0550ae}.highlight .ne{color:#0550ae}.highlight .nl{color:#0550ae}.highlight .py{color:#0550ae}.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#0550ae}.highlight .o,.highlight .ow{color:#0550ae}.highlight .gh{color:#0550ae;font-weight:bold}.highlight .gu{color:#0550ae;font-weight:bold}.highlight .s,.highlight .sa,.highlight .sc,.highlight .dl,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .sx,.highlight .s1,.highlight .ss{color:#0a3069}.highlight .nd{color:#8250df}.highlight .nf,.highlight .fm{color:#8250df}.highlight .err{color:#f6f8fa;background-color:#82071e}.highlight .c,.highlight .ch,.highlight .cd,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .c1,.highlight .cs{color:#6e7781}.highlight .gl{color:#6e7781}.highlight .gt{color:#6e7781}.highlight .ni{color:#24292f}.highlight .si{color:#24292f}.highlight .ge{color:#24292f;font-style:italic}.highlight .gs{color:#24292f;font-weight:bold}*,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0}body{font-family:-apple-system,BlinkMacSystemFont,"avenir next",avenir,helvetica,"helvetica neue",ubuntu,roboto,noto,"segoe ui",arial,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none;font-weight:bold}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none;padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:0 auto 2rem auto;padding:1rem}.title{margin:2rem auto 0 auto;max-width:60rem;padding-left:12rem;font-size:24px}.title a{text-decoration:none;font-weight:bold}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.section-nav{background-color:#fff;margin:5px 0;padding:10px 30px;border:1px solid #e8e8e8;border-radius:3px}figcaption{font-size:smaller}.pagination{margin-top:1.5rem;display:flex;align-items:center;gap:1rem;margin-left:auto}.pagination .page_number{margin-right:1rem}.pagination .page_number .current{font-weight:bold}.pagination img{width:24px;height:24px;display:block;padding:4px}.pagination img.disabled{opacity:.3}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-150864545-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-150864545-1'); </script></head><body><div class="title"> <a href="/">김민식 기술블로그</a></div><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Posts</a></li><li><a href="/categories" >Categories</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li></ul></nav></header><section class="post"><h1>[Spring] @RestControllerAdvice에서 body 로깅으로 남기기</h1><div class="toc"><ol id="toc" class="section-nav"><li class="toc-entry toc-h1"><a href="#20240511-----restcontrolleradvice-에서-body-로깅으로-남기기md">2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md</a><ol><li class="toc-entry toc-h2"><a href="#사건의-발단">사건의 발단</a></li><li class="toc-entry toc-h2"><a href="#httpservletrequest-에서-값을-읽을-때는-내부적으로-inputstream-을-사용한다">HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.</a></li><li class="toc-entry toc-h2"><a href="#contentcachingrequestwrapper">ContentCachingRequestWrapper</a></li><li class="toc-entry toc-h2"><a href="#적용">적용</a><ol><li class="toc-entry toc-h3"><a href="#참고">참고</a></li></ol></li></ol></li></ol></div><div class="content"><h1 id="20240511-----restcontrolleradvice-에서-body-로깅으로-남기기md">2024.05.11 - 🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md</h1><h2 id="사건의-발단">사건의 발단</h2><p>현재 진행하고 있는 프로젝트에서는 @RestControllerAdvice 를 이용하여 예외를 전역으로 처리하고 있다.<br /> 예외가 났을 때 어떤 요청값이 들어와서 예외가 발생했는 지 로그로 남기고 싶어서 request 의 body 를 읽고 싶었으나 아무런 값이 없는 문제가 발생했다.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code>
<span class="nd">@Slf4j</span>
<span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>

  <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">HotelkingException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ApiResponse</span><span class="o">&lt;</span><span class="nc">ErrorContent</span><span class="o">&gt;&gt;</span> <span class="nf">handleHotelkingException</span><span class="o">(</span>
      <span class="nc">HotelkingException</span> <span class="n">e</span><span class="o">,</span>
      <span class="nc">HttpServletRequest</span> <span class="n">request</span>
  <span class="o">){</span>
    <span class="nc">ErrorCode</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getErrorCode</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="nc">StreamUtils</span><span class="o">.</span><span class="na">copyToString</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"body = {}"</span><span class="o">,</span> <span class="n">body</span><span class="o">);</span> <span class="c1">// 슬프게도 아무것도 안나온다.</span>
    <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="n">ec</span><span class="o">.</span><span class="na">getHttpStatus</span><span class="o">()).</span><span class="na">body</span><span class="o">(</span><span class="nc">ApiResponse</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="nc">ErrorContent</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">ec</span><span class="o">)));</span>
  <span class="o">}</span>

  <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">HttpMessageNotReadableException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ApiResponse</span><span class="o">&lt;</span><span class="nc">ErrorContent</span><span class="o">&gt;&gt;</span> <span class="nf">handleHttpMessageNotReadableException</span><span class="o">(</span><span class="nc">HttpMessageNotReadableException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ErrorCode</span> <span class="n">ec</span> <span class="o">=</span> <span class="nc">ErrorCode</span><span class="o">.</span><span class="na">NOT_READABLE</span><span class="o">;</span>
    <span class="n">printLog</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">ec</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">ResponseEntity</span>
        <span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">ErrorCode</span><span class="o">.</span><span class="na">NOT_READABLE</span><span class="o">.</span><span class="na">getHttpStatus</span><span class="o">())</span>
        <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="nc">ApiResponse</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="nc">ErrorContent</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">ec</span><span class="o">)));</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div><p>HttpServletRequest 에서 다시 한번 InputStream 을 이용하여 body 를 읽으려고 했지만 아무것도 읽을 수 없었다.</p><h2 id="httpservletrequest-에서-값을-읽을-때는-내부적으로-inputstream-을-사용한다">HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.</h2><blockquote><p>The spring-web module contains the HttpMessageConverter interface for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for concurrency, in the RestClient) and on the server side (for concurrency, in Spring MVC REST controllers).</p></blockquote><p><img src="https://velog.velcdn.com/images/kmss6905/post/bc215933-2cc6-43a4-9a7f-36dc13766dee/image.png" alt="" /></p><p>Spring MVC 는 Servlet API 기반으로 만들어졌다. Spring MVC 에서는 Dispatcher Servlet 이 그 역할을 담당하고 있다. Http 요청을 다룰 때 HttpServletRequest 에서 요청 body 를 읽을 때 <code class="language-html highlighter-rouge">getInputStream()</code> 그리고 <code class="language-html highlighter-rouge">getReader()</code> 메서드를 제공한다. 이러한 각 메소드는 동일한 InputStream 을 사용하기 때문에 InputStream을 한 번 읽으면 다시 읽을 수 없는 문제가 있다.</p><h2 id="contentcachingrequestwrapper">ContentCachingRequestWrapper</h2><p><code class="language-html highlighter-rouge">ContentCachingRequestWrapper</code> 는 생성자로 받은 HttpServeltRequest 를 input stream 과 reader 로 부터 모든 HttpServletRequest 컨텐츠를 캐시하는 HttpServlerRequest Wrapper 클래스이다.</p><p>캐시한 content 는 byte array 형태로 다시 얻을 수 있다.</p><p>얻을 때는 <code class="language-html highlighter-rouge">getContentAsByteArray()</code> 를 통해 다시 얻을 수 있다.</p><p>중요한 건 요청 컨텐츠가 consumed 되지 않았다면, 컨텐츠는 캐시되지 않는다.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContentCachingRequestWrapper</span> <span class="kd">extends</span> <span class="nc">HttpServletRequestWrapper</span> <span class="o">{</span>

<span class="kd">private</span> <span class="kd">final</span> <span class="nc">FastByteArrayOutputStream</span> <span class="n">cachedContent</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">ContentCachingRequestWrapper</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
		
		<span class="c1">// 캐시 하는 부분</span>
		<span class="kt">int</span> <span class="n">contentLength</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getContentLength</span><span class="o">();</span>
		
		<span class="c1">// content 가 있는 경우 캐시한다.</span>
		<span class="k">this</span><span class="o">.</span><span class="na">cachedContent</span> <span class="o">=</span> <span class="o">(</span><span class="n">contentLength</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">FastByteArrayOutputStream</span><span class="o">(</span><span class="n">contentLength</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">FastByteArrayOutputStream</span><span class="o">();</span>
		<span class="k">this</span><span class="o">.</span><span class="na">contentCacheLimit</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="o">...</span>
	
	<span class="c1">// 캐시한 컨텐츠를 가져온다.</span>
	<span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getContentAsByteArray</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cachedContent</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>엄청 특이한 건 없다.</p><p>다만 <code class="language-html highlighter-rouge">FastByteArrayOutputStream</code> 이라고 하는 OutputStream 을 extend 하여 새롭게 만들어 사용하고 있다. 문서에서는 ByteArrayOutputStream 의 대안으로 나왔다고 한다.</p><p>참고로 <code class="language-html highlighter-rouge">AbstractRequestLoggingFilter</code> 에서도 위의 <code class="language-html highlighter-rouge">ContentCachingRequestWrapper</code> 가 사용된다.</p><p><img src="https://velog.velcdn.com/images/kmss6905/post/8eb4fafc-4f37-4855-9bb4-8a8bc838a0d5/image.png" alt="" /></p><h2 id="적용">적용</h2><p>Custom Filter 를 만들어 기존 HttpServletRequest 를 캐싱할 수 있도록 들어온 HttpServletRequest 를 이용하여 ContentCachingRequestWrapper 객체를 만든 후 doFilter를 호출합니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CachingFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
      <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="k">new</span> <span class="nc">ContentCachingRequestWrapper</span><span class="o">(</span><span class="n">request</span><span class="o">),</span> <span class="n">response</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="참고">참고</h3><ul><li>https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-message-conversion</li></ul></div><div class="meta"> <time datetime="2024-05-11T00:00:00+09:00">May 11, 2024</time><p> categories: <a href="/category/Spring">Spring</a></p><p> tags: <a href="/tag/spring">spring</a> , <a href="/tag/spring boot">spring boot</a> , <a href="/tag/restcontrolleradvice">restcontrolleradvice</a> , <a href="/tag/filter">filter</a> , <a href="/tag/contentcachingrequestwrapper">contentcachingrequestwrapper</a> , <a href="/tag/logging">logging</a> , <a href="/tag/exception handling">exception handling</a></p></div><script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script></section></main></body></html>
