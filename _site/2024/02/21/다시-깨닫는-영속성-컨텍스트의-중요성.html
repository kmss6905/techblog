<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성" /><meta name="author" content="김민식" /><meta property="og:locale" content="en_US" /><meta name="description" content="분산락을 이용한 동시성 제어 코드 작성 중 발생한 문제를 통해 영속성 컨텍스트와 DB 격리 레벨의 중요성을 다시 한번 깨달았습니다. 문제 원인 분석과 해결 과정을 공유합니다." /><meta property="og:description" content="분산락을 이용한 동시성 제어 코드 작성 중 발생한 문제를 통해 영속성 컨텍스트와 DB 격리 레벨의 중요성을 다시 한번 깨달았습니다. 문제 원인 분석과 해결 과정을 공유합니다." /><link rel="canonical" href="http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1" /><meta property="og:url" content="http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1" /><meta property="og:site_name" content="김민식 기술블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-02-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"김민식","url":"https://minshikkim.com"},"dateModified":"2024-02-21T00:00:00+09:00","datePublished":"2024-02-21T00:00:00+09:00","description":"분산락을 이용한 동시성 제어 코드 작성 중 발생한 문제를 통해 영속성 컨텍스트와 DB 격리 레벨의 중요성을 다시 한번 깨달았습니다. 문제 원인 분석과 해결 과정을 공유합니다.","headline":"다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1"},"url":"http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1"}</script><title> 다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성 - 김민식 기술블로그</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="김민식 기술블로그" href="/atom.xml"><link rel="alternate" type="application/json" title="김민식 기술블로그" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> .highlight table td{padding:5px}.highlight table pre{margin:0}.highlight,.highlight .w{color:#24292f;background-color:#f6f8fa}.highlight .k,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .kv{color:#cf222e}.highlight .gr{color:#f6f8fa}.highlight .gd{color:#82071e;background-color:#ffebe9}.highlight .nb{color:#953800}.highlight .nc{color:#953800}.highlight .no{color:#953800}.highlight .nn{color:#953800}.highlight .sr{color:#116329}.highlight .na{color:#116329}.highlight .nt{color:#116329}.highlight .gi{color:#116329;background-color:#dafbe1}.highlight .ges{font-weight:bold;font-style:italic}.highlight .kc{color:#0550ae}.highlight .l,.highlight .ld,.highlight .m,.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .il,.highlight .mo,.highlight .mx{color:#0550ae}.highlight .sb{color:#0550ae}.highlight .bp{color:#0550ae}.highlight .ne{color:#0550ae}.highlight .nl{color:#0550ae}.highlight .py{color:#0550ae}.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#0550ae}.highlight .o,.highlight .ow{color:#0550ae}.highlight .gh{color:#0550ae;font-weight:bold}.highlight .gu{color:#0550ae;font-weight:bold}.highlight .s,.highlight .sa,.highlight .sc,.highlight .dl,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .sx,.highlight .s1,.highlight .ss{color:#0a3069}.highlight .nd{color:#8250df}.highlight .nf,.highlight .fm{color:#8250df}.highlight .err{color:#f6f8fa;background-color:#82071e}.highlight .c,.highlight .ch,.highlight .cd,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .c1,.highlight .cs{color:#6e7781}.highlight .gl{color:#6e7781}.highlight .gt{color:#6e7781}.highlight .ni{color:#24292f}.highlight .si{color:#24292f}.highlight .ge{color:#24292f;font-style:italic}.highlight .gs{color:#24292f;font-weight:bold}*,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0}body{font-family:-apple-system,BlinkMacSystemFont,"avenir next",avenir,helvetica,"helvetica neue",ubuntu,roboto,noto,"segoe ui",arial,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none;font-weight:bold}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none;padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:0 auto 2rem auto;padding:1rem}.title{margin:2rem auto 0 auto;max-width:60rem;padding-left:12rem;font-size:24px}.title a{text-decoration:none;font-weight:bold}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.section-nav{background-color:#fff;margin:5px 0;padding:10px 30px;border:1px solid #e8e8e8;border-radius:3px}figcaption{font-size:smaller}.pagination{margin-top:1.5rem;display:flex;align-items:center;gap:1rem;margin-left:auto}.pagination .page_number{margin-right:1rem}.pagination .page_number .current{font-weight:bold}.pagination img{width:24px;height:24px;display:block;padding:4px}.pagination img.disabled{opacity:.3}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-150864545-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-150864545-1'); </script></head><body><div class="title"> <a href="/">김민식 기술블로그</a></div><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Posts</a></li><li><a href="/categories" >Categories</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li></ul></nav></header><section class="post"><h1>다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성</h1><div class="toc"><ol id="toc" class="section-nav"><li class="toc-entry toc-h1"><a href="#다시금-깨닫는-영속성-컨텍스트와-db-격리-레벨의-중요성">다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성</a><ol><li class="toc-entry toc-h2"><a href="#원인-분석-및-해결-과정">원인 분석 및 해결 과정</a><ol><li class="toc-entry toc-h3"><a href="#문제-상황-데이터-불일치">문제 상황: 데이터 불일치</a></li><li class="toc-entry toc-h3"><a href="#시도-1-락-해제-시점-변경">시도 1: 락 해제 시점 변경</a></li><li class="toc-entry toc-h3"><a href="#진짜-원인-repeatable-read-격리-레벨">진짜 원인: REPEATABLE READ 격리 레벨</a></li></ol></li><li class="toc-entry toc-h2"><a href="#해결-방안">해결 방안</a></li><li class="toc-entry toc-h2"><a href="#추가-고려사항-영속성-컨텍스트-스코프">추가 고려사항: 영속성 컨텍스트 스코프</a></li></ol></li></ol></div><div class="content"><h1 id="다시금-깨닫는-영속성-컨텍스트와-db-격리-레벨의-중요성">다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성</h1><blockquote><p>분산락(Distributed Lock) 관련 코드를 작성하고 테스트하던 중, 예상치 못한 결과가 계속 발생했습니다. 원인을 파고들어 보니, 제가 간과하고 있던 중요한 개념들이 있었습니다. 이 글에서는 그 과정에서 얻은 교훈을 공유하고자 합니다.</p></blockquote><p>결론부터 말하자면, 문제의 원인은 다음과 같았습니다.</p><ol><li><strong>영속성 컨텍스트</strong>를 제대로 이해하지 못했던 것</li><li><strong>Lock의 범위</strong>를 잘못 설정했던 것</li><li>(가장 중요) MySQL <strong>InnoDB 엔진의 기본 격리 레벨(Isolation Level)</strong>을 고려하지 않았던 것</li></ol><p><img src="https://www.baeldung.com/wp-content/uploads/2016/10/Hibernate-Persistence-Context-2.png" alt="영속성 컨텍스트" /></p><h2 id="원인-분석-및-해결-과정">원인 분석 및 해결 과정</h2><h3 id="문제-상황-데이터-불일치">문제 상황: 데이터 불일치</h3><p>문제의 코드는 다음과 같았습니다. <code class="language-html highlighter-rouge">reserve</code> 메서드는 <code class="language-html highlighter-rouge">roomId</code>를 받아 해당 방의 재고(<code class="language-html highlighter-rouge">RoomStock</code>)를 감소시키는 로직입니다. 동시성 문제를 해결하기 위해 분산락을 사용했습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">reserve</span><span class="o">(</span><span class="kt">long</span> <span class="n">roomId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 1. 락 획득 시도</span>
        <span class="nc">Long</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">roomId</span><span class="o">),</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">lock</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 획득 실패"</span><span class="o">);</span>
            <span class="k">return</span> <span class="s">"fail"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 획득!"</span><span class="o">);</span>

        <span class="c1">// 2. 재고 조회 및 감소</span>
        <span class="nc">RoomStock</span> <span class="n">roomStock</span> <span class="o">=</span> <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">findRoomStockByRoomId</span><span class="o">(</span><span class="n">roomId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>
        <span class="n">roomStock</span><span class="o">.</span><span class="na">decrease</span><span class="o">();</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 3. 락 해제</span>
        <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">releaseLock</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">roomId</span><span class="o">));</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 해제!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>이 코드의 가장 큰 문제는 <strong>영속성 컨텍스트</strong>에 있었습니다. 락을 획득한 후 <code class="language-html highlighter-rouge">findRoomStockByRoomId</code> 메서드로 <code class="language-html highlighter-rouge">RoomStock</code> 객체를 조회할 때, JPA는 먼저 영속성 컨텍스트(1차 캐시)를 확인합니다. 만약 이전에 같은 <code class="language-html highlighter-rouge">roomId</code>로 조회한 <code class="language-html highlighter-rouge">RoomStock</code> 객체가 영속성 컨텍스트에 존재한다면, <strong>데이터베이스를 다시 조회하지 않고 캐시에 있는 객체를 그대로 반환</strong>합니다.</p><p>이로 인해 다른 스레드가 이미 재고를 변경하고 커밋했더라도, 현재 스레드는 변경 전의 데이터를 가지고 <code class="language-html highlighter-rouge">decrease()</code> 메서드를 호출하게 되어 <strong>데이터 불일치</strong>가 발생합니다.</p><h3 id="시도-1-락-해제-시점-변경">시도 1: 락 해제 시점 변경</h3><p>처음에는 락을 너무 빨리 해제해서 문제가 발생한다고 생각했습니다. <code class="language-html highlighter-rouge">commit</code>이 되기 전에 다른 스레드가 락을 획득하고, 아직 변경사항이 반영되지 않은 데이터를 읽어간다고 추측했습니다. 하지만 MySQL의 <code class="language-html highlighter-rouge">general_log</code>를 확인해 본 결과, 그런 상황은 발생하지 않았습니다.</p><p><img src="images/img.png" alt="MySQL general_log" /></p><h3 id="진짜-원인-repeatable-read-격리-레벨">진짜 원인: REPEATABLE READ 격리 레벨</h3><p>문제의 핵심은 MySQL InnoDB 스토리지 엔진의 기본 격리 레벨인 <strong>REPEATABLE READ</strong>에 있었습니다. 이 격리 레벨에서는 <strong>트랜잭션이 시작될 때의 데이터 스냅샷</strong>을 만들어, 트랜잭션이 진행되는 동안에는 해당 스냅샷의 데이터만 읽습니다. 따라서 다른 트랜잭션이 데이터를 변경하고 커밋하더라도, 현재 트랜잭션은 그 변경사항을 볼 수 없습니다.</p><p>위 로그에서 <code class="language-html highlighter-rouge">1961</code>번 트랜잭션이 커밋한 이후에 <code class="language-html highlighter-rouge">1962</code>번 트랜잭션이 데이터를 조회했지만, <code class="language-html highlighter-rouge">1962</code>번 트랜잭션은 자신이 시작될 때의 스냅샷을 기준으로 데이터를 읽었기 때문에 변경 전의 데이터를 가져온 것입니다.</p><h2 id="해결-방안">해결 방안</h2><p>이 문제를 해결하기 위해 다음과 같이 코드를 수정했습니다.</p><ol><li><strong>락 획득 후, 새로운 트랜잭션에서 재고 조회 및 감소 로직 실행</strong></li><li><code class="language-html highlighter-rouge">@Transactional(propagation = Propagation.REQUIRES_NEW)</code> 옵션을 사용하여 <code class="language-html highlighter-rouge">decrease</code> 메서드가 항상 새로운 트랜잭션에서 실행되도록 강제합니다. 이렇게 하면 <code class="language-html highlighter-rouge">decrease</code> 메서드가 호출될 때마다 새로운 스냅샷을 생성하여 최신 데이터를 읽어올 수 있습니다.</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// ReservationService.java</span>
<span class="nd">@Service</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReservationService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoomStockRepository</span> <span class="n">roomStockRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoomStockService</span> <span class="n">roomStockService</span><span class="o">;</span>

    <span class="c1">// ... 생성자</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reserve</span><span class="o">(</span><span class="kt">long</span> <span class="n">roomId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Long</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">roomId</span><span class="o">),</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">lock</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 획득 실패"</span><span class="o">);</span>
                <span class="k">return</span> <span class="s">"fail"</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 획득!"</span><span class="o">);</span>
            <span class="c1">// 별도의 트랜잭션을 가진 서비스 메서드 호출</span>
            <span class="n">roomStockService</span><span class="o">.</span><span class="na">decrease</span><span class="o">(</span><span class="n">roomId</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">releaseLock</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">roomId</span><span class="o">));</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"락 해제!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// RoomStockService.java</span>
<span class="nd">@Slf4j</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RoomStockService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoomStockRepository</span> <span class="n">roomStockRepository</span><span class="o">;</span>

    <span class="c1">// ... 생성자</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrease</span><span class="o">(</span><span class="kt">long</span> <span class="n">roomId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">RoomStock</span> <span class="n">roomStock</span> <span class="o">=</span> <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">findRoomStockByRoomId</span><span class="o">(</span><span class="n">roomId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>
            <span class="n">roomStock</span><span class="o">.</span><span class="na">decrease</span><span class="o">();</span>
            <span class="c1">// 변경사항을 즉시 DB에 반영</span>
            <span class="n">roomStockRepository</span><span class="o">.</span><span class="na">saveAndFlush</span><span class="o">(</span><span class="n">roomStock</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="추가-고려사항-영속성-컨텍스트-스코프">추가 고려사항: 영속성 컨텍스트 스코프</h2><p>JPA의 영속성 컨텍스트는 기본적으로 <strong>트랜잭션 스코프(Transaction-Scoped)</strong>를 가집니다. 즉, 영속성 컨텍스트의 생명주기는 트랜잭션의 생명주기와 동일합니다. 트랜잭션이 시작될 때 생성되고, 트랜잭션이 끝날 때(커밋 또는 롤백) 사라집니다.</p><p><code class="language-html highlighter-rouge">@PersistenceContext</code> 어노테이션의 <code class="language-html highlighter-rouge">type</code> 속성을 통해 <strong>확장 스코프(Extended-Scoped)</strong>를 사용할 수도 있습니다. 확장 스코프는 여러 트랜잭션에 걸쳐 영속성 컨텍스트를 유지할 수 있게 해주지만, 명시적으로 <code class="language-html highlighter-rouge">flush</code>를 호출해야 변경사항이 반영되므로 주의해서 사용해야 합니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nd">@Repeatable</span><span class="o">(</span><span class="nc">PersistenceContexts</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="no">TYPE</span><span class="o">,</span> <span class="no">METHOD</span><span class="o">,</span> <span class="no">FIELD</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="no">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">PersistenceContext</span> <span class="o">{</span>

   <span class="c1">// ...</span>

   <span class="cm">/**
    * (Optional) Specifies whether a transaction-scoped persistence context 
    * or an extended persistence context is to be used.
    */</span>
   <span class="nc">PersistenceContextType</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="nc">PersistenceContextType</span><span class="o">.</span><span class="na">TRANSACTION</span><span class="o">;</span>
   
   <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>이번 경험을 통해 동시성 문제를 다룰 때는 코드 로직뿐만 아니라, JPA의 영속성 컨텍스트와 데이터베이스의 격리 레벨까지 깊이 있게 이해하는 것이 얼마나 중요한지 다시 한번 깨닫게 되었습니다.</p></div><div class="meta"> <time datetime="2024-02-21T00:00:00+09:00">February 21, 2024</time><p> categories: <a href="/category/JPA">JPA</a> , <a href="/category/Spring">Spring</a></p><p> tags: <a href="/tag/jpa">jpa</a> , <a href="/tag/영속성 컨텍스트">영속성 컨텍스트</a> , <a href="/tag/db 격리 레벨">db 격리 레벨</a> , <a href="/tag/동시성">동시성</a> , <a href="/tag/분산락">분산락</a> , <a href="/tag/spring">spring</a></p></div><script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script></section></main></body></html>
