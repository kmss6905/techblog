{
    "version": "https://jsonfeed.org/version/1",
    "title": "김민식 기술블로그",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "공부하고 경험한 것을 기록합니다.",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "김민식",
        "url": "https://minshikkim.com",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2025/04/17/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B0%9C%EB%B0%9C%ED%95%A0-%EB%95%8C-%EB%8D%94-%EA%B0%9C%EC%84%A0%ED%95%A0-%EC%97%AC%EC%A7%80%EB%8A%94-%EC%97%86%EB%8A%94-%EC%A7%80-%EA%B3%A0%EB%AF%BC%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94",
            "title": "주니어 개발자가 개발할 때 더 개선할 여지는 없는지 고민해보자",
            "summary": "주니어 개발자로서 코드 작성 시 성능, 안전성, 리소스 등 다양한 관점에서 '이게 최선일까?'를 고민하는 습관의 중요성을 예제와 함께 설명합니다.",
            "content_text": "2025.04.17 - [쉬운코드]주니어 개발자가 개발할 때 더 개선할 여지는 없는 지 고민 해보자예제 1. 1부터 N 까지의 정수 합(Sum)을 구하는 함수를 작성public static int intSum(int n){    int sum = 0;    while (n &gt;= 1) {        sum += n --;    }    return sum;}// 성능 훨 좋다.public static int intSum3(int n){    return n * (n + 1) / 2;}System.out.println(intSum(1_000_000));System.out.println(intSum(1_000_000));1784293664-363189984// long type 으로 바꿔보자public static int intSum4(int n){    if (n % 2 == 0) {        return (n / 2) * (n + 1);    }else {        return n * ((n + 1) / 2);    }}System.out.println(intSum(1_000_000));System.out.println(intSum(1_000_000));17842936641784293664예제 2. 배치작업상황  어떤 기기가 1분 마다 스캔한 데이터를 DB에 저장하고 있는 상황  해당 기기가 100대가 있음  배치 작업 : 검수를 위해 하루 한번 100대가 하루 동안 스캔한 데이터를 각각의 압축 파일로 만들어서 3rd party API 를 통해 업로드생각 1. 🤔  최초에 배치는 싱글 스레드로 구현 : 총 7시간 정도 소요  이걸 스레드 10개로 증가 : 총 3시간 정도로 시간 단축  하지만 더 개선할 여지는 없을까??생각 2. 🤔왜 스레드 개수를 열개 로 잡았는가 ?? 일단 한번 트라이??  하나의 태스크를 조금 더 구체적으로 분석해보자          기기 한 대가 하루 동안 스캔한 데이터를 압축      압축 파일을 검수 API에 업로드      1번의 경우 CPU bound, 소요 시간은 약 4분2번의 경우 I/O bound, 소요 시간 약 1분I/O bound 일 때는 스레드가 적당히 많으면 오히려 병렬성에 좋음CPU bound 일 때는 스레드가 많으면 ?? 서버 core 수!  CPU bound → 소요시간 약 4분          CPU Bound 일 때는 스레드가 많으면?                  서버 Core 수          배치서버는 2core                          압축하는 동안에 다른 거 할 수 없다.                                            IO Bound → 소요시간 약 1분          IO 바운드일 때는 스레드가 적당히 많으면 오히려 병렬성에 좋다.        왜 스레드 개수를 열개로 잡았는가???? → 음.. 열개가 최선의 선택은 아닐 수 있다! 더 나은 스레드 개수가 있을 수 있음!, 다섯개로 조정해볼까?  최적의 스레드 수를 찾는 게 베스트일까? 오버 엔지니어링 아닐까??          기기 100개 이지만, 더 늘어날 수도 있고      센싱하는 데이터가 1분마다가 아니라 더 늘어날 수도 있고? …      음.. 그러면 앞으로 스레드 수 찾는 게 가변 적일 건데 이게 오버엔지니어링 아닐까?        관점의 재점검!! : 스레드 수 조정 외에 다른 접근 은 없을까?(내가 스레드에만 몰입 한 것이 아닐까?)          scale up! core 수 증가!      scale out! 더 많은 서버 사용!!        이게 최선일까? 현재 서버 스펙에서 더 개선할 여지는 없을까?          기기 한대가 하루 동안 스캔한 데이터를 압축 : CPU bound, 약 4분 소요      압축 파일을 검수 API 에 업로드 : I/O bound, 약 1분소요      ⇒ 기기 100대에 대해서 1번 작업부터 먼저 다하고 이어서 2번 작업을 한번에 하면 어떨까?  1번 작업할 때는 2~3개 스레드      2번 작업 때 비동기 호출(WebClient, etc…)    이게 최선일 까? 더 개선할 여지는 없을까? (추가로 고려해볼 만한 내용)          검수 API에 부하를 주진 않을까? (동시에 몇개의 파일을 업로드 할 지 고려)      DB에서 데이터를 읽어올 때 하루치 스캔 데이터를 한번에 다 읽어보면 서버 메모리는 괜찮을까?                  1기가 DB에 있다고 가정 → 1기가 전부를 배치 어플에 올려둔다? → 이건 메모리에 부담이다.                          그러면 한번에 읽지 말고, 스트림 방식으로 가져와서 파일을 떨구는 건 어떨까?              스트림 방식으로 압축 파일 생성 방법 검색                                  etc) 압축알고리즘은 또 어떤게 있지? (검수 API 쪽에서 허용되는 압축포맷도 확인해봐야하는 부분이고…)                                                                        예제 3. 캐싱(Caching)private Cache&lt;Integer, CachedProduct&gt; productCache = Caffeine.newBuilder().build();CachedProduct product = productCache.getIfPresent(productId);product.price = (int)Math.ceil(product.price / usdToWonRate); // 달러로 바꿈 &lt;- 문제가 되는 부분// 달러로 바꾸는 과정은 캐시된 데이터 를 기준으로 바꾸고 있다.!! 힙 메모리를 참조하고 있기 떄문// 완전망한다. 10000 원화가 -&gt; 5달러로 그대로 바뀐채로 계속 !public record CachedProduct(int id, String modelName, int price) {\tpublic int id;\tpublic String modelName;\tpublic int price;}음.. 그러면 어떻게 개선할 수 있을까?price 를 바꿀 수 있어서 그런거라고 생각해서 final 을 붙이는 게 최선일까 ? 결국 cached 된 것들은 값을 바꾸면 안되는 건가? → 불변객체로 만들어야 한다.?내가 저장하는 데이터를 캐싱, 참조될거고, 맘대로 바꾸면 위험할 듯public final class CachedProduct {    private final int id;    private final String modelName;    private final int price;    public CachedProduct(int id, String modelName, int price) {        this.id = id;        this.modelName = modelName;        this.price = price;    }}public record CachedProduct {\tint id;\tString modelName;\tint price;}CachedProduct 의 타입이 primitive type 이 아닌 List 가 추가 된다면?? 어떻게 될까?  List 를 불변객체 ?List …그 외 생각해볼 것  우리 사이트에서 물품을 원화(KRW)로만 판매하다가 , 달러 (USD)로도 판매할 예정이다.          백엔드 프론트 각각 코드를 조금씩 고치면 달러로도 판매하게 끔 만들 수 있다.                  음 이게 최선일까?                    그런데 앞으로 일본과 동남아 쪽도 공략 예정이라고 한다.      엔화 등 추가적인 통화 (currency) 지원이 필요할 수 있다.      이 상황에서 어떤 것이 최선일까?                  매번 통화가 추가될때 마다 백엔드 프론트 코드를 조금 씩 고치는 게 나을까?          아니면 어드민 페이지에서 딸깍 한번이면 통화 추가가 자유롭게 추가 삭제 되는 게 좋을까?                    정리 : 이게 최선일까? 고민하는 습관      성능 혹은 안전성의 관점에서 늘 고민        리소스는 언제나 한정되어 있다.        명확한 근거를 추구하고 있는가 ? (단, 너무 집착, 오버엔지니어링은 경계할 것)        바라보는 관점을 다양화 하기(내가 너무 스레드 개수로만 집착하지 않았는 가? .., db? redis ? 방법론 측면에서 ?! )        더 편할 순 없는가?  …출처https://www.youtube.com/watch?v=ZWWUSN13Wzw",
            "content_html": "<h1 id=\"20250417---쉬운코드주니어-개발자가-개발할-때-더-개선할-여지는-없는-지-고민-해보자\">2025.04.17 - [쉬운코드]주니어 개발자가 개발할 때 더 개선할 여지는 없는 지 고민 해보자</h1><h2 id=\"예제-1-1부터-n-까지의-정수-합sum을-구하는-함수를-작성\">예제 1. 1부터 N 까지의 정수 합(Sum)을 구하는 함수를 작성</h2><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">intSum</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">){</span>    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">n</span> <span class=\"o\">--;</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"c1\">// 성능 훨 좋다.</span><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">intSum3</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">){</span>    <span class=\"k\">return</span> <span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">intSum</span><span class=\"o\">(</span><span class=\"mi\">1_000_000</span><span class=\"o\">));</span><span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">intSum</span><span class=\"o\">(</span><span class=\"mi\">1_000_000</span><span class=\"o\">));</span><span class=\"mi\">1784293664</span><span class=\"o\">-</span><span class=\"mi\">363189984</span></code></pre></div></div><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"c1\">// long type 으로 바꿔보자</span><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">intSum4</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">){</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"k\">else</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">intSum</span><span class=\"o\">(</span><span class=\"mi\">1_000_000</span><span class=\"o\">));</span><span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">intSum</span><span class=\"o\">(</span><span class=\"mi\">1_000_000</span><span class=\"o\">));</span><span class=\"mi\">1784293664</span><span class=\"mi\">1784293664</span></code></pre></div></div><h2 id=\"예제-2-배치작업\">예제 2. 배치작업</h2><h4 id=\"상황\">상황</h4><ul>  <li>어떤 기기가 1분 마다 스캔한 데이터를 DB에 저장하고 있는 상황</li>  <li>해당 기기가 100대가 있음</li>  <li>배치 작업 : 검수를 위해 하루 한번 100대가 하루 동안 스캔한 데이터를 각각의 압축 파일로 만들어서 3rd party API 를 통해 업로드</li></ul><hr /><h3 id=\"생각-1-\">생각 1. 🤔</h3><ul>  <li>최초에 배치는 싱글 스레드로 구현 : 총 7시간 정도 소요</li>  <li>이걸 스레드 10개로 증가 : 총 3시간 정도로 시간 단축</li>  <li>하지만 더 개선할 여지는 없을까??</li></ul><hr /><h3 id=\"생각-2-\">생각 2. 🤔</h3><p>왜 스레드 개수를 <em>열개</em> 로 잡았는가 ?? 일단 한번 트라이??</p><ul>  <li>하나의 태스크를 조금 더 구체적으로 분석해보자    <ol>      <li>기기 한 대가 하루 동안 스캔한 데이터를 압축</li>      <li>압축 파일을 검수 API에 업로드</li>    </ol>  </li></ul><p>1번의 경우 CPU bound, 소요 시간은 약 4분2번의 경우 I/O bound, 소요 시간 약 1분</p><hr /><p>I/O bound 일 때는 스레드가 적당히 많으면 오히려 병렬성에 좋음CPU bound 일 때는 스레드가 많으면 ?? 서버 core 수!</p><ol>  <li>CPU bound → 소요시간 약 4분    <ol>      <li>CPU Bound 일 때는 스레드가 많으면?        <ol>          <li>서버 Core 수</li>          <li>배치서버는 2core            <ol>              <li>압축하는 동안에 다른 거 할 수 없다.</li>            </ol>          </li>        </ol>      </li>    </ol>  </li>  <li>IO Bound → 소요시간 약 1분    <ol>      <li>IO 바운드일 때는 스레드가 적당히 많으면 오히려 병렬성에 좋다.</li>    </ol>  </li></ol><ul>  <li>왜 스레드 개수를 열개로 잡았는가???? → 음.. 열개가 최선의 선택은 아닐 수 있다! 더 나은 스레드 개수가 있을 수 있음!, 다섯개로 조정해볼까?</li>  <li>최적의 스레드 수를 찾는 게 베스트일까? 오버 엔지니어링 아닐까??    <ul>      <li>기기 100개 이지만, 더 늘어날 수도 있고</li>      <li>센싱하는 데이터가 1분마다가 아니라 더 늘어날 수도 있고? …</li>      <li>음.. 그러면 앞으로 스레드 수 찾는 게 가변 적일 건데 이게 오버엔지니어링 아닐까?</li>    </ul>  </li>  <li>관점의 재점검!! : 스레드 수 조정 외에 다른 접근 은 없을까?(내가 스레드에만 몰입 한 것이 아닐까?)    <ul>      <li>scale up! core 수 증가!</li>      <li>scale out! 더 많은 서버 사용!!</li>    </ul>  </li>  <li>이게 최선일까? 현재 서버 스펙에서 더 개선할 여지는 없을까?    <ol>      <li>기기 한대가 하루 동안 스캔한 데이터를 압축 : CPU bound, 약 4분 소요</li>      <li>압축 파일을 검수 API 에 업로드 : I/O bound, 약 1분소요</li>    </ol>  </li></ul><p>⇒ 기기 100대에 대해서 1번 작업부터 먼저 다하고 이어서 2번 작업을 한번에 하면 어떨까?</p><ul>  <li>1번 작업할 때는 2~3개 스레드</li>  <li>    <p>2번 작업 때 비동기 호출(WebClient, etc…)</p>  </li>  <li>이게 최선일 까? 더 개선할 여지는 없을까? (추가로 고려해볼 만한 내용)    <ul>      <li>검수 API에 부하를 주진 않을까? (동시에 몇개의 파일을 업로드 할 지 고려)</li>      <li>DB에서 데이터를 읽어올 때 하루치 스캔 데이터를 한번에 다 읽어보면 서버 메모리는 괜찮을까?        <ul>          <li>1기가 DB에 있다고 가정 → 1기가 전부를 배치 어플에 올려둔다? → 이건 메모리에 부담이다.            <ul>              <li>그러면 한번에 읽지 말고, 스트림 방식으로 가져와서 파일을 떨구는 건 어떨까?</li>              <li>스트림 방식으로 압축 파일 생성 방법 검색                <ul>                  <li>etc) 압축알고리즘은 또 어떤게 있지? (검수 API 쪽에서 허용되는 압축포맷도 확인해봐야하는 부분이고…)</li>                </ul>              </li>            </ul>          </li>        </ul>      </li>    </ul>  </li></ul><h2 id=\"예제-3-캐싱caching\">예제 3. 캐싱(Caching)</h2><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">private</span> <span class=\"nc\">Cache</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">,</span> <span class=\"nc\">CachedProduct</span><span class=\"o\">&gt;</span> <span class=\"n\">productCache</span> <span class=\"o\">=</span> <span class=\"nc\">Caffeine</span><span class=\"o\">.</span><span class=\"na\">newBuilder</span><span class=\"o\">().</span><span class=\"na\">build</span><span class=\"o\">();</span><span class=\"nc\">CachedProduct</span> <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"n\">productCache</span><span class=\"o\">.</span><span class=\"na\">getIfPresent</span><span class=\"o\">(</span><span class=\"n\">productId</span><span class=\"o\">);</span><span class=\"n\">product</span><span class=\"o\">.</span><span class=\"na\">price</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span><span class=\"nc\">Math</span><span class=\"o\">.</span><span class=\"na\">ceil</span><span class=\"o\">(</span><span class=\"n\">product</span><span class=\"o\">.</span><span class=\"na\">price</span> <span class=\"o\">/</span> <span class=\"n\">usdToWonRate</span><span class=\"o\">);</span> <span class=\"c1\">// 달러로 바꿈 &lt;- 문제가 되는 부분</span><span class=\"c1\">// 달러로 바꾸는 과정은 캐시된 데이터 를 기준으로 바꾸고 있다.!! 힙 메모리를 참조하고 있기 떄문</span><span class=\"c1\">// 완전망한다. 10000 원화가 -&gt; 5달러로 그대로 바뀐채로 계속 !</span></code></pre></div></div><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">record</span> <span class=\"nf\">CachedProduct</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">modelName</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">price</span><span class=\"o\">)</span> <span class=\"o\">{</span>\t<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">;</span>\t<span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"n\">modelName</span><span class=\"o\">;</span>\t<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"n\">price</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p>음.. 그러면 어떻게 개선할 수 있을까?</p><p>price 를 바꿀 수 있어서 그런거라고 생각해서 final 을 붙이는 게 최선일까 ? 결국 cached 된 것들은 값을 바꾸면 안되는 건가? → 불변객체로 만들어야 한다.?</p><p>내가 저장하는 데이터를 캐싱, 참조될거고, 맘대로 바꾸면 위험할 듯</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">CachedProduct</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">modelName</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">price</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"nf\">CachedProduct</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">modelName</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">price</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span> <span class=\"o\">=</span> <span class=\"n\">id</span><span class=\"o\">;</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">modelName</span> <span class=\"o\">=</span> <span class=\"n\">modelName</span><span class=\"o\">;</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">price</span> <span class=\"o\">=</span> <span class=\"n\">price</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">record</span> <span class=\"nc\">CachedProduct</span> <span class=\"o\">{</span>\t<span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">;</span>\t<span class=\"nc\">String</span> <span class=\"n\">modelName</span><span class=\"o\">;</span>\t<span class=\"kt\">int</span> <span class=\"n\">price</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p>CachedProduct 의 타입이 primitive type 이 아닌 List 가 추가 된다면?? 어떻게 될까?  List 를 불변객체 ?</p><p>List<Seller> …</Seller></p><p>그 외 생각해볼 것</p><ul>  <li>우리 사이트에서 물품을 원화(KRW)로만 판매하다가 , 달러 (USD)로도 판매할 예정이다.    <ul>      <li>백엔드 프론트 각각 코드를 조금씩 고치면 달러로도 판매하게 끔 만들 수 있다.        <ul>          <li>음 이게 최선일까?</li>        </ul>      </li>      <li>그런데 앞으로 일본과 동남아 쪽도 공략 예정이라고 한다.</li>      <li>엔화 등 추가적인 통화 (currency) 지원이 필요할 수 있다.</li>      <li>이 상황에서 어떤 것이 최선일까?        <ul>          <li>매번 통화가 추가될때 마다 백엔드 프론트 코드를 조금 씩 고치는 게 나을까?</li>          <li>아니면 어드민 페이지에서 딸깍 한번이면 통화 추가가 자유롭게 추가 삭제 되는 게 좋을까?</li>        </ul>      </li>    </ul>  </li></ul><h2 id=\"정리--이게-최선일까-고민하는-습관\">정리 : 이게 최선일까? 고민하는 습관</h2><ul>  <li>    <p>성능 혹은 안전성의 관점에서 늘 고민</p>  </li>  <li>    <p>리소스는 언제나 한정되어 있다.</p>  </li>  <li>    <p>명확한 근거를 추구하고 있는가 ? (단, 너무 집착, 오버엔지니어링은 경계할 것)</p>  </li>  <li>    <p>바라보는 관점을 다양화 하기(내가 너무 스레드 개수로만 집착하지 않았는 가? .., db? redis ? 방법론 측면에서 ?! )</p>  </li>  <li>    <p>더 편할 순 없는가?</p>  </li></ul><p>…</p><h3 id=\"출처\">출처</h3><hr /><p>https://www.youtube.com/watch?v=ZWWUSN13Wzw</p>",
            "url": "http://localhost:4000/2025/04/17/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B0%9C%EB%B0%9C%ED%95%A0-%EB%95%8C-%EB%8D%94-%EA%B0%9C%EC%84%A0%ED%95%A0-%EC%97%AC%EC%A7%80%EB%8A%94-%EC%97%86%EB%8A%94-%EC%A7%80-%EA%B3%A0%EB%AF%BC%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94",
            
            
            
            "tags": ["주니어개발자","성장","코드개선","성능최적화","쉬운코드","클린코드","개발문화"],
            
            "date_published": "2025-04-17T00:00:00+09:00",
            "date_modified": "2025-04-17T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/11/15/%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%84-%EC%9D%98%EC%8B%AC%ED%95%98%EC%9E%90-%EC%82%BD%EC%A7%88%EC%9D%B4%ED%9B%84-feat-%EB%B6%80%ED%95%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%88%B4",
            "title": "모든 것을 의심하자, 삽질 이후... (feat. 부하테스트 툴)",
            "summary": "부하 테스트 툴(nGrinder, Apache Bench)의 결과와 실제 애플리케이션의 요청 수가 다른 현상을 발견하고 원인을 분석합니다. 테스트 툴의 결과를 맹신하지 말고 모든 것을 의심해야 한다는 교훈을 얻었습니다.",
            "content_text": "2024.11.15 - 모든 것을 의심하자. 삽질이후.. (feat. 부하테스트 툴)나는 동시성 테스트를 하기 위해 NGrinder 와 Apache Bench 를 사용했다. 대략적인 계획은 이러하다.쿠폰 발급이라고 예시를 들면  수량이 1억개인 쿠폰이 있다고 가정하고, 1000명, 10000명 동시에 쿠폰 발급 요청을 했을 때 정확히 유저의 요청 수 만큼 쿠폰이 발급되었는 지를 확인한다.문제는 실제 시간을 두고 계속해서 부하를 줬을 때(NGrinder 의 경우 3분동안 부하테스트 시행) 실제 총 실행 테스트를 했을 경우이다.아래의 테스트 결과에서는 총 실행테스트가 22546 개의 요청을 날린 것으로 나와있지만, 실제로는 그보다 많은 23120 개의 요청이 들어온 것을 알 수 있다.NGrinder    그림 1 - NGrinder 테스트 결과   Apache BenchAB 테스트 역시 마찬가지 였다. 실제로 -t 옵션을 주지 않았을 때는 문제가 되지 않았지만, -t 옵션을 통해 시간을 두고 부하 테스트를 했을 경우도 마찬가지로 실제 요청 수와 차이가 있었다    그림 2 - Apache Bench 테스트 결과   AB 테스트 결과에는 1084 개의 완료된 요청이 있다고 했지만 실제로는 그 보다 9개 많은 1093 개의 요청이 들어온 것을 알 수 있다.    그림 3 - 실제 app 내에서 측정한 요청 카운트   확인 방법접속 카운트를 저장하는 변수는 스레드에 안전해야 하기 때문에 Java 에서 제공하는 단일 연산 변수 AtomicLong 를 이용하여 요청 카운트를 저장했다.  private final AtomicLong count = new AtomicLong(0L);\t  @GetMapping(\"/pay-result-v2\")  public ResponseEntity&lt;String&gt; payResultV2() {    count.getAndIncrement();    try {      roomReservationService.reserve(1L);    } catch (RuntimeException e) {      return ResponseEntity.status(400).build();    }    return ResponseEntity.ok(\"ok\");  }  @GetMapping(\"/result-request\")  public String totalRequestCount() {    return \"total request count : \" + count.get();  }깨달은 점사실 처음에는 동시성에 대한 코드가 잘못된 줄 알았다. 하지만 동시성을 제어하는 코드에는 아무런 이상이 없었다. 실제로 테스트 코드를 돌려봤을 때는 모두 통과했었다.하지만 유독 시간을 두는 테스트에서만 문제가 생기는 것을 의심했고 직접 카운트를 찍었을 때 툴에서의 결과와 다른 것을 알 수 있었다.툴에 나오는 요청 횟수를 그대로 믿었기에, 한 동안 나의 코드가 잘못되었는 지 계속 살펴보았다.생각해보면 부하테스트는 정확한 요청 카운트가 중요하지 않을 수 있다. 특히 시간을 두고 점차적인 부하테스트를 할 때 1억건의 요청을 날리는 데 10, 100 정도 요청이 차이난다고 해서 시스템 병목을 파악하고 어느 정도 요청에 대한 Throughput 을 가지는 지를 파악못하는 것은 아니기 때문이다.추가 수정(2024/11/15)이와 관련된 글이 있는 지 찾아보고 수정함.  nGrinder 의 경우 log 파일의 test 수와 web 상에 나타나는 executed test 수가 다를 수 있다고 한다. 왜냐하면 별도의 샘플링이라는 데이터 수집 프로세스를 이용하여 결과가 합산되는 데, 이때 테스트 종료시에 샘플링이 일부 누락되어 조금의 차이가 발생할 수 있고 이는 알려진 이슈라고 한다.(링크참조)      테스트    참고로 nGrinder 는 에이전트당 1개의 프로세스 로그만 볼 수 있기 때문에 1agent, vuser 1000 (1process, 1000 thread) 로 테스트 했다(그림 1의 경우에는 로그파일을 보면 한개의 프로세스만 볼 수 있어서 전체 요청 수 확인 불가함.)테스트 결과 실제 application 에서 측정한 요청 수 와 일치하는 것을 확인할 수 있었다!      그림 4 - 1agent, vuser 1000 (1process, 1000 thread), nGrinder 테스트 결과 log 파일 중 일부    그림 5 - 실제 application 에서 측정한 요청 수참고  http://ngrinder.373.s1.nabble.com/exected-test-td2531.html",
            "content_html": "<h1 id=\"20241115---모든-것을-의심하자-삽질이후-feat-부하테스트-툴\">2024.11.15 - 모든 것을 의심하자. 삽질이후.. (feat. 부하테스트 툴)</h1><p>나는 동시성 테스트를 하기 위해 NGrinder 와 Apache Bench 를 사용했다. 대략적인 계획은 이러하다.</p><p>쿠폰 발급이라고 예시를 들면</p><blockquote>  <p>수량이 1억개인 쿠폰이 있다고 가정하고, 1000명, 10000명 동시에 쿠폰 발급 요청을 했을 때 정확히 유저의 요청 수 만큼 쿠폰이 발급되었는 지를 확인한다.</p></blockquote><p>문제는 실제 시간을 두고 계속해서 부하를 줬을 때(NGrinder 의 경우 3분동안 부하테스트 시행) 실제 총 실행 테스트를 했을 경우이다.아래의 테스트 결과에서는 총 실행테스트가 <strong>22546</strong> 개의 요청을 날린 것으로 나와있지만, 실제로는 그보다 많은 <strong>23120</strong> 개의 요청이 들어온 것을 알 수 있다.</p><h3 id=\"ngrinder\">NGrinder</h3><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/ngrinder.png\" /><br />  <em>그림 1 - NGrinder 테스트 결과</em>   </p><h3 id=\"apache-bench\">Apache Bench</h3><p>AB 테스트 역시 마찬가지 였다. 실제로 -t 옵션을 주지 않았을 때는 문제가 되지 않았지만, -t 옵션을 통해 시간을 두고 부하 테스트를 했을 경우도 마찬가지로 실제 요청 수와 차이가 있었다</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/apache_bench_result.png\" /><br />  <em>그림 2 - Apache Bench 테스트 결과</em>   </p><p>AB 테스트 결과에는 1084 개의 완료된 요청이 있다고 했지만 실제로는 그 보다 9개 많은 <strong>1093</strong> 개의 요청이 들어온 것을 알 수 있다.</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/count_result.png\" /><br />  <em>그림 3 - 실제 app 내에서 측정한 요청 카운트</em>   </p><h3 id=\"확인-방법\">확인 방법</h3><p>접속 카운트를 저장하는 변수는 스레드에 안전해야 하기 때문에 Java 에서 제공하는 단일 연산 변수 <strong>AtomicLong</strong> 를 이용하여 요청 카운트를 저장했다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code>  <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">AtomicLong</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">AtomicLong</span><span class=\"o\">(</span><span class=\"mi\">0L</span><span class=\"o\">);</span>\t  <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/pay-result-v2\"</span><span class=\"o\">)</span>  <span class=\"kd\">public</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">payResultV2</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndIncrement</span><span class=\"o\">();</span>    <span class=\"k\">try</span> <span class=\"o\">{</span>      <span class=\"n\">roomReservationService</span><span class=\"o\">.</span><span class=\"na\">reserve</span><span class=\"o\">(</span><span class=\"mi\">1L</span><span class=\"o\">);</span>    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">RuntimeException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>      <span class=\"k\">return</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">.</span><span class=\"na\">status</span><span class=\"o\">(</span><span class=\"mi\">400</span><span class=\"o\">).</span><span class=\"na\">build</span><span class=\"o\">();</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">.</span><span class=\"na\">ok</span><span class=\"o\">(</span><span class=\"s\">\"ok\"</span><span class=\"o\">);</span>  <span class=\"o\">}</span>  <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/result-request\"</span><span class=\"o\">)</span>  <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">totalRequestCount</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"k\">return</span> <span class=\"s\">\"total request count : \"</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"o\">}</span></code></pre></div></div><h3 id=\"깨달은-점\">깨달은 점</h3><p>사실 처음에는 동시성에 대한 코드가 잘못된 줄 알았다. 하지만 동시성을 제어하는 코드에는 아무런 이상이 없었다. 실제로 테스트 코드를 돌려봤을 때는 모두 통과했었다.하지만 유독 시간을 두는 테스트에서만 문제가 생기는 것을 의심했고 직접 카운트를 찍었을 때 툴에서의 결과와 다른 것을 알 수 있었다.</p><p>툴에 나오는 요청 횟수를 그대로 믿었기에, 한 동안 나의 코드가 잘못되었는 지 계속 살펴보았다.생각해보면 부하테스트는 정확한 요청 카운트가 중요하지 않을 수 있다. 특히 시간을 두고 점차적인 부하테스트를 할 때 1억건의 요청을 날리는 데 10, 100 정도 요청이 차이난다고 해서 시스템 병목을 파악하고 어느 정도 요청에 대한 Throughput 을 가지는 지를 파악못하는 것은 아니기 때문이다.</p><h3 id=\"추가-수정20241115\">추가 수정(2024/11/15)</h3><p>이와 관련된 글이 있는 지 찾아보고 수정함.</p><ul>  <li>nGrinder 의 경우 log 파일의 test 수와 web 상에 나타나는 executed test 수가 다를 수 있다고 한다. 왜냐하면 별도의 샘플링이라는 데이터 수집 프로세스를 이용하여 결과가 합산되는 데, 이때 테스트 종료시에 샘플링이 일부 누락되어 조금의 차이가 발생할 수 있고 이는 알려진 이슈라고 한다.(<a href=\"http://ngrinder.373.s1.nabble.com/exected-test-td2531.html\">링크참조</a>)  <br /><br />    <h3 id=\"테스트\">테스트</h3>    <p>참고로 nGrinder 는 에이전트당 1개의 프로세스 로그만 볼 수 있기 때문에 1agent, vuser 1000 (1process, 1000 thread) 로 테스트 했다(그림 1의 경우에는 로그파일을 보면 한개의 프로세스만 볼 수 있어서 전체 요청 수 확인 불가함.)<br />테스트 결과 실제 application 에서 측정한 요청 수 와 일치하는 것을 확인할 수 있었다!</p>  </li></ul><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/ngrinder2_logfile.png\" /><br />  <em>그림 4 - 1agent, vuser 1000 (1process, 1000 thread), nGrinder 테스트 결과 log 파일 중 일부</em></p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/count2.png\" /><br />  <em>그림 5 - 실제 application 에서 측정한 요청 수</em></p><p><br /></p><h3 id=\"참고\">참고</h3><ul>  <li>http://ngrinder.373.s1.nabble.com/exected-test-td2531.html</li></ul>",
            "url": "http://localhost:4000/2024/11/15/%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%84-%EC%9D%98%EC%8B%AC%ED%95%98%EC%9E%90-%EC%82%BD%EC%A7%88%EC%9D%B4%ED%9B%84-feat-%EB%B6%80%ED%95%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%88%B4",
            
            
            
            "tags": ["부하테스트","nGrinder","Apache Bench","성능 테스트","삽질"],
            
            "date_published": "2024-11-15T00:00:00+09:00",
            "date_modified": "2024-11-15T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/10/24/%EA%B2%8C%EC%9D%B4%EB%B0%8D-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91%EC%9C%BC%EB%A1%9C-%ED%99%88%EC%84%9C%EB%B2%84-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0",
            "title": "게이밍 데스크탑으로 홈서버 운영하기",
            "summary": "클라우드 서비스의 비용 부담으로 인해 남는 게이밍 데스크탑을 활용하여 홈서버를 구축한 경험을 공유합니다. WSL과 Docker를 이용하여 리눅스 환경을 구성하고 토이 프로젝트를 운영하는 과정을 소개합니다.",
            "content_text": "2024.10.24 - 게이밍 데스크탑으로 홈서버 운영하기  NCP Platform → Google Cloud → Oracle Cloud 를 거쳐 토이프로젝트 서버로 홈서버를 이용하기로 했다.배경NCP 에서 제공해주던 100만원 크레딧은 아직 남았지만, 유효기간이 곧 끝나가는 터라 결국 다른 클라우드를 알아보았고 Google Cloud 로 넘어 갔다.그러나 결국 크래딧으로 버틸 뿐이라 이 또한 마음에 썩 들지는 않았다. 물론 매번 계정을 Google 계정 만들고 크레딧 받는 과정을 반복하면 된다.Oracle Cloud 의 경우 평생 무료 서버를 2개 제공하고 있지만 매우매우 저 사양 스팩이라 토이 프로젝트로 쓰기에는 부적합했다.(모니터링 툴 까지 생각하면 어림도 없다..)현재 프로젝트 구조초창기 프로젝트 구조와 거의 흡사하다. 다만, Vercel 로 운영하지 않은 것이 조금 차이가 난다. (포스팅 참조 : 비사이드 401 - Green Developers 프로젝트 후기)    그림 1 - 과거의 토이프로젝트 구조   프론트(Next.js)와 백엔드(Spring Boot, Redis, MySQL) 모두 관리의 편의성을 위해 컨테이너 형태로 운영하고 있다.Next.js 와 Spring Boot 와 같은 Application 들은 따로 Application Server 에서 운영하고 나머지 Redis, MySQL 은 DB Server 에서 운영한다. Application Server 와 DB Server 는 같은 Private Subnet 에 있기 때문에 Private IP 로 서로 통신이 가능하다.참고로 개발서버도 운영하고 싶었지만, 그럴 여력이 될 수 없었다. 이미 하나씩 자리를 차지하고 있었기 때문에 초마이크로 서버에 4개의 컨테이너를 띄우고 운영하기에는 너무 버겁다.(각 운영용, 개발용)Google Cloud 를 사용할 때는 개발 서버도 운영했지만 결국 크래딧이 고갈되었다.기존에 사용하던 클라우드 보다는 오버스팩이지만, 별 사용하지 않는 데스크탑을 사용하는 것이기 때문에 별 부담은 없었다.(전기료만 내면 된다).현재 네트워크 토폴로지    그림 2 - 집의 네트워크 토폴로지   우리 집의 네트워크 토폴리지 구성도는 다음과 같다모뎀으로 부터 2개의 공인 IP를 부여받아서 사용하고 있고 하나는 Desktop(pc), 그리고 나머지 하나는 공유기에 연결하여 사용하고 있다.공유기 아래에 pc 를 연결하여 사용할 수도 있지만 독립된 네트워크를 구성하고 싶었다. (KT의 유선정책이 정확히 어떻게 되는 지는 알아봐야 겠지만, 공인 ip 할당이 2개까지 되는 걸로 알고있다. 어떤 글에서는 4개.. 8개도 된다고 한다..)공유기 아래에 연결되어있다면 따로 공인 ip로 접속했을 때 서버로 사용될 pc 로 트래픽이 흐르게 하기 위해 포트포워딩 작업이 필요하겠지만 따로 ip를 할당 받았기 때문에 굳이 그럴 필요는 없다.WSL vs 가상머신에서 Linux 운영체제현재 게이밍 데스크탑의 경우 운영체제가 윈도우 이고 추후에도 윈도우를 이용해 작업할 경우가 굉장히 많고 게임도 해야하기 때문에 운영체제를 바꿀 수는 없다.그렇다고 윈도우 운영체제 그 자체를 서버로 사용하기에는 여간 불편한게 아니다. 따라서 리눅스 환경에서 서버를 운영하고 싶었는 데 나에겐 선택지가 두 개가 있었다.  가상 머신을 설치하고 새로운 컴퓨터를 띄우는 방법  WSL을 사용하여 Windows에 Linux를 설치해서 사용하기나는 가볍게 사용할 생각이라 WSL 을 사용해서 Linux 를 설치했다.그리고 Docker 를 사용하여 모든 서버와 모니터링 관련 애플리케이션들은 이미지로 만들어서 컨테이너로 운영했다.프로젝트 구경하기URL : https://nyangnyang.co.kr",
            "content_html": "<h1 id=\"20241024---게이밍-데스크탑으로-홈서버-운영하기\">2024.10.24 - 게이밍 데스크탑으로 홈서버 운영하기</h1><blockquote>  <p><em>NCP Platform → Google Cloud → Oracle Cloud 를 거쳐 토이프로젝트 서버로 홈서버를 이용하기로 했다.</em></p></blockquote><h2 id=\"배경\">배경</h2><p>NCP 에서 제공해주던 100만원 크레딧은 아직 남았지만, 유효기간이 곧 끝나가는 터라 결국 다른 클라우드를 알아보았고 Google Cloud 로 넘어 갔다.<br />그러나 결국 크래딧으로 버틸 뿐이라 이 또한 마음에 썩 들지는 않았다. 물론 매번 계정을 Google 계정 만들고 크레딧 받는 과정을 반복하면 된다.Oracle Cloud 의 경우 평생 무료 서버를 2개 제공하고 있지만 매우매우 저 사양 스팩이라 토이 프로젝트로 쓰기에는 부적합했다.(<del>모니터링 툴 까지 생각하면 어림도 없다..</del>)</p><p><br /><br /></p><h2 id=\"현재-프로젝트-구조\">현재 프로젝트 구조</h2><p>초창기 프로젝트 구조와 거의 흡사하다. 다만, Vercel 로 운영하지 않은 것이 조금 차이가 난다. (포스팅 참조 : <a href=\"https://velog.io/@kmss6905/%EB%B9%84%EC%82%AC%EC%9D%B4%EB%93%9C-401-Green-Developers-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0\">비사이드 401 - Green Developers 프로젝트 후기</a>)</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/oracle_cloud.png\" /><br />  <em>그림 1 - 과거의 토이프로젝트 구조</em>   </p><p>프론트(Next.js)와 백엔드(Spring Boot, Redis, MySQL) 모두 관리의 편의성을 위해 컨테이너 형태로 운영하고 있다.</p><p>Next.js 와 Spring Boot 와 같은 Application 들은 따로 Application Server 에서 운영하고 나머지 Redis, MySQL 은 DB Server 에서 운영한다. Application Server 와 DB Server 는 같은 Private Subnet 에 있기 때문에 Private IP 로 서로 통신이 가능하다.</p><p>참고로 개발서버도 운영하고 싶었지만, 그럴 여력이 될 수 없었다. 이미 하나씩 자리를 차지하고 있었기 때문에 초마이크로 서버에 4개의 컨테이너를 띄우고 운영하기에는 너무 버겁다.(각 운영용, 개발용)</p><p>Google Cloud 를 사용할 때는 개발 서버도 운영했지만 결국 크래딧이 고갈되었다.</p><p>기존에 사용하던 클라우드 보다는 오버스팩이지만, 별 사용하지 않는 데스크탑을 사용하는 것이기 때문에 별 부담은 없었다.(전기료만 내면 된다).</p><p><br /><br /></p><h2 id=\"현재-네트워크-토폴로지\">현재 네트워크 토폴로지</h2><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/topology.png\" /><br />  <em>그림 2 - 집의 네트워크 토폴로지</em>   </p><p>우리 집의 네트워크 토폴리지 구성도는 다음과 같다</p><p>모뎀으로 부터 2개의 공인 IP를 부여받아서 사용하고 있고 하나는 Desktop(pc), 그리고 나머지 하나는 공유기에 연결하여 사용하고 있다.</p><p>공유기 아래에 pc 를 연결하여 사용할 수도 있지만 독립된 네트워크를 구성하고 싶었다. (KT의 유선정책이 정확히 어떻게 되는 지는 알아봐야 겠지만, <del>공인 ip 할당이 2개까지 되는 걸로 알고있다. 어떤 글에서는 4개.. 8개도 된다고 한다..</del>)</p><p>공유기 아래에 연결되어있다면 따로 공인 ip로 접속했을 때 서버로 사용될 pc 로 트래픽이 흐르게 하기 위해 포트포워딩 작업이 필요하겠지만 따로 ip를 할당 받았기 때문에 굳이 그럴 필요는 없다.</p><p><br /><br /></p><h2 id=\"wsl-vs-가상머신에서-linux-운영체제\">WSL vs 가상머신에서 Linux 운영체제</h2><p>현재 게이밍 데스크탑의 경우 운영체제가 윈도우 이고 추후에도 윈도우를 이용해 작업할 경우가 굉장히 많고 게임도 해야하기 때문에 운영체제를 바꿀 수는 없다.</p><p>그렇다고 윈도우 운영체제 그 자체를 서버로 사용하기에는 여간 불편한게 아니다. 따라서 리눅스 환경에서 서버를 운영하고 싶었는 데 나에겐 선택지가 두 개가 있었다.</p><ol>  <li><strong>가상 머신을 설치하고 새로운 컴퓨터를 띄우는 방법</strong></li>  <li><strong>WSL을 사용하여 Windows에 Linux를 설치해서 사용하기</strong></li></ol><p>나는 가볍게 사용할 생각이라 WSL 을 사용해서 Linux 를 설치했다.그리고 Docker 를 사용하여 모든 서버와 모니터링 관련 애플리케이션들은 이미지로 만들어서 컨테이너로 운영했다.</p><h3 id=\"프로젝트-구경하기\">프로젝트 구경하기</h3><p>URL : https://nyangnyang.co.kr</p>",
            "url": "http://localhost:4000/2024/10/24/%EA%B2%8C%EC%9D%B4%EB%B0%8D-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91%EC%9C%BC%EB%A1%9C-%ED%99%88%EC%84%9C%EB%B2%84-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0",
            
            
            
            "tags": ["홈서버","wsl","docker","네트워크","토이프로젝트"],
            
            "date_published": "2024-10-24T00:00:00+09:00",
            "date_modified": "2024-10-24T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/09/18/jvm-bump-pointer-allocation-and-thread-local-allocation-buffer",
            "title": "JVM 메모리 할당 효율성 높이기: Bump pointer allocation과 TLAB",
            "summary": "JVM은 멀티스레드 환경에서 메모리 할당 시 충돌을 방지하고 효율성을 높이기 위해 Bump pointer allocation과 TLAB(Thread-Local Allocation Buffer) 기술을 사용합니다. 이 글에서는 두 기술의 원리와 장점을 알아봅니다.",
            "content_text": "JVM 메모리 할당 효율성 높이기 - Bump pointer allocation 과Thread-Local Allocation Buffer  Java 에서 객체 생성시 JVM 의 Heap 영역에 메모리가 할당된다. 하지만 JVM 은 기본적으로 Multi-Thread 환경이기 때문에 메모리 할당시 메모리 충돌을 방지하기 위해 Bump the pointer 과 Thread-Local-Buffer(TLAB) 라는 기술을 추가하였는 데 이에 대해서 간단히 정리해보았다.Bump the pointer새로운 객체를 만들면 JVM 이 Heap 영역에 새로운 객체를 위해서 메모리를 할당해야하는데, 비어있는 메모리를 찾을 때 JVM은 탐색하는 시간을 줄이기 위해 할당된 메모리 바로 뒤에 메모리를 할당하는 방법을 사용하는 데 이를 Bump pointer allocation 이라고 합니다.  대부분의 Gabage Collector 는 Gabage Collection 시 압축(Compat) 하는 과정을 통해 파편화된 메모리 공간을 하나로 모으는 작업을 합니다.Thread-Local Allocation Buffer등장배경new 라는 키워드를 통해 새로운 객체를 생성했을 때를 가정해보겠습니다.하나의 스레드가 새로운 객체를 메모리에 할당하기 위해 비어있는 메모리 주소를 요청하게 됩니다.  이때 Bump the pointer 를 사용하고 있기 때문에 가장 최근에 할당된 메모리 공간 바로 뒤의 주소를 요청 받게 됩니다.문제는 JVM 은 멀티 스레드를 지원하기 때문에 여러개의 스레드가 최근에 할당된 메모리 공간을 동시에 요청하면 동시화 이슈가 발생하게 됩니다.    그림 1 - 싱글스레드의 메모리 요청   이렇게 그림 1 과 같이 오직 하나의 스레드에 대해서 할당 요청하는 경우에는 메모리 크기를 요청하는 스레드가 하나이기 때문에 동기화 문제가 발생하지 않습니다.    그림 2 - 멀티스레드의 메모리 요청   그림 2 처럼 여러개의 Thread 가 동시에 메모리를 요청하려고 하는 경우 충돌이 발생할 수 있습니다. 당연히 이럴 경우에는 Lock 과 같은 동기화 작업이 수행됩니다.만약 10개의 스레드가 같은 메모리 공간을 요청하려고 한다면 최초 할당을 요청한 스레드가 락을 풀때까지 뒤에 9개의 스레드가 대기하게 되고 이는 Application 의 성능저하를 유발할 수 있습니다.    그림 3 - TLAB   이러한 문제를 해결하기 위해 JVM 은 TLAB(Thread-Local Allocation Buffer) 이라는 기술을 도입했습니다.TLAB(Thread-Local Allocation Buffer)는 그림 3 과 같이 각 스레드에게 Eden 영역의 일부를 독점적으로 할당하여, 해당 스레드가 객체를 생성할 때 동기화 없이 빠르게 메모리를 할당할 수 있도록 합니다.(물론 TLAB 를 Thread 에게 최초로 할당하거나 TLAB 가 부족해서 새롭게 할당 받을 때는 동기화 이슈가 발생하는 것은 어쩔 수 없지만, 그래도 사용하지 않았을 때보다는 동기화 이슈가 많이 줄어 들어 메모리 할당에 걸리는 시간이 줄어드는 건 장점으로 작용합니다.)요약JVM 은 객체에 대한 메모리 할당 요청시 비어 있는 메모리를 찾는 시간을 줄이기 위해 최근 할당된 메모리 공간 바로 뒤의 메모리 공간을 요청하는 방식의 **Bump pointer allocation** 을 사용하고 있습니다.Multi Thread 환경에서 같은 메모리 공간을 동시에 여러 스레드가 요청할 경우 동기화 이슈로 인한 병목현상이 발생하게 됩니다.이를 방지하기 위해 Heap 에 Thread 별로 공간을 나누어 대기 현상 없이 메모리 할당을 가능하게 하는 방법인 **Thread Local Allocation Buffer(TLAB)** 라는 기술을 추가하였습니다.Referencehttps://www.baeldung.com/java-jvm-tlabhttps://inside.java/2020/06/25/compact-forwarding/김한도, 『JAVA PERFORMANCE FUNDAMENTAL』, 엑셈(2009), 108-109",
            "content_html": "<h1 id=\"jvm-메모리-할당-효율성-높이기---bump-pointer-allocation-과thread-local-allocation-buffer\">JVM 메모리 할당 효율성 높이기 - Bump pointer allocation 과Thread-Local Allocation Buffer</h1><blockquote>  <p>Java 에서 객체 생성시 JVM 의 Heap 영역에 메모리가 할당된다. 하지만 JVM 은 기본적으로 Multi-Thread 환경이기 때문에 메모리 할당시 메모리 충돌을 방지하기 위해 Bump the pointer 과 Thread-Local-Buffer(TLAB) 라는 기술을 추가하였는 데 이에 대해서 간단히 정리해보았다.</p></blockquote><h3 id=\"bump-the-pointer\">Bump the pointer</h3><p>새로운 객체를 만들면 JVM 이 Heap 영역에 새로운 객체를 위해서 메모리를 할당해야하는데, 비어있는 메모리를 찾을 때 JVM은 탐색하는 시간을 줄이기 위해 할당된 메모리 바로 뒤에 메모리를 할당하는 방법을 사용하는 데 이를 <strong>Bump pointer allocation</strong> 이라고 합니다.</p><blockquote>  <p>대부분의 Gabage Collector 는 Gabage Collection 시 압축(Compat) 하는 과정을 통해 파편화된 메모리 공간을 하나로 모으는 작업을 합니다.</p></blockquote><h3 id=\"thread-local-allocation-buffer\"><strong>Thread-Local Allocation Buffer</strong></h3><h4 id=\"등장배경\">등장배경</h4><p>new 라는 키워드를 통해 새로운 객체를 생성했을 때를 가정해보겠습니다.</p><p>하나의 스레드가 새로운 객체를 메모리에 할당하기 위해 비어있는 메모리 주소를 요청하게 됩니다.  이때 Bump the pointer 를 사용하고 있기 때문에 가장 최근에 할당된 메모리 공간 바로 뒤의 주소를 요청 받게 됩니다.<br />문제는 JVM 은 멀티 스레드를 지원하기 때문에 여러개의 스레드가 최근에 할당된 메모리 공간을 동시에 요청하면 동시화 이슈가 발생하게 됩니다.</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/single_thread_allocation_request.png\" /><br />  <em>그림 1 - 싱글스레드의 메모리 요청</em>   </p><p><br /></p><p>이렇게 <em>그림 1</em> 과 같이 오직 하나의 스레드에 대해서 할당 요청하는 경우에는 메모리 크기를 요청하는 스레드가 하나이기 때문에 동기화 문제가 발생하지 않습니다.</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/multi_thread_allocation_collision.png\" /><br />  <em>그림 2 - 멀티스레드의 메모리 요청</em>   </p><p><br /></p><p><em>그림 2</em> 처럼 여러개의 Thread 가 동시에 메모리를 요청하려고 하는 경우 충돌이 발생할 수 있습니다. 당연히 이럴 경우에는 Lock 과 같은 동기화 작업이 수행됩니다.만약 10개의 스레드가 같은 메모리 공간을 요청하려고 한다면 최초 할당을 요청한 스레드가 락을 풀때까지 뒤에 9개의 스레드가 대기하게 되고 이는 Application 의 성능저하를 유발할 수 있습니다.</p><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/multi_thread_memory_allocation_request.png\" /><br />  <em>그림 3 - TLAB</em>   </p><p><br /></p><p>이러한 문제를 해결하기 위해 JVM 은 <u>TLAB(Thread-Local Allocation Buffer)</u> 이라는 기술을 도입했습니다.</p><p><u>TLAB(Thread-Local Allocation Buffer)</u>는 <em>그림 3</em> 과 같이 각 스레드에게 Eden 영역의 일부를 독점적으로 할당하여, 해당 스레드가 객체를 생성할 때 동기화 없이 빠르게 메모리를 할당할 수 있도록 합니다.</p><p>(물론 TLAB 를 Thread 에게 최초로 할당하거나 TLAB 가 부족해서 새롭게 할당 받을 때는 동기화 이슈가 발생하는 것은 어쩔 수 없지만, 그래도 사용하지 않았을 때보다는 동기화 이슈가 많이 줄어 들어 메모리 할당에 걸리는 시간이 줄어드는 건 장점으로 작용합니다.)</p><h3 id=\"요약\">요약</h3><p>JVM 은 객체에 대한 메모리 할당 요청시 비어 있는 메모리를 찾는 시간을 줄이기 위해 최근 할당된 메모리 공간 바로 뒤의 메모리 공간을 요청하는 방식의 <u>**Bump pointer allocation**</u> 을 사용하고 있습니다.</p><p>Multi Thread 환경에서 같은 메모리 공간을 동시에 여러 스레드가 요청할 경우 동기화 이슈로 인한 병목현상이 발생하게 됩니다.이를 방지하기 위해 Heap 에 Thread 별로 공간을 나누어 대기 현상 없이 메모리 할당을 가능하게 하는 방법인 <u>**Thread Local Allocation Buffer(TLAB)**</u> 라는 기술을 추가하였습니다.</p><hr /><h3 id=\"reference\">Reference</h3><p>https://www.baeldung.com/java-jvm-tlab<br />https://inside.java/2020/06/25/compact-forwarding/<br />김한도, <strong>『</strong>JAVA PERFORMANCE FUNDAMENTAL<strong>』</strong>, 엑셈(2009), 108-109</p>",
            "url": "http://localhost:4000/2024/09/18/jvm-bump-pointer-allocation-and-thread-local-allocation-buffer",
            
            
            
            "tags": ["jvm","tlab","bump the pointer","memory allocation","performance"],
            
            "date_published": "2024-09-18T00:00:00+09:00",
            "date_modified": "2024-09-18T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/09/16/%EC%9D%98%EB%AF%B8%EA%B0%80-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EA%B0%99%EB%8B%A4%EB%A9%B4-%EC%9D%91%EB%8B%B5-%ED%95%84%EB%93%9C-%EC%9D%B4%EB%A6%84%EB%8F%84-%EA%B0%99%EA%B2%8C%ED%95%98%EC%9E%90",
            "title": "의미가 완벽하게 같다면 응답 필드 이름도 같게하자",
            "summary": "API 응답에서 의미가 같은 필드는 동일한 이름을 사용해야 한다는 교훈을 얻었습니다. 필드 이름이 다를 경우 발생하는 혼란과 비효율을 줄이고, 일관성 있는 API를 설계하는 것의 중요성을 강조합니다.",
            "content_text": "의미가 같다면 응답 필드 이름도 같도록 하자! - 나를 위해서 모두를 위해서  같은 필드이고 그 의미가 다른 곳에서도 똑같이 적용되는 경우라면 왠만하면 통일되게 이름을 가져가는 것이 좋다고 생각이 든다.이냥저냥 토이프로젝트에서는 개별 고양이 컨텐츠를 상세 조회하거나 리스트 형태로 볼 수 있는 기능이 있다.그리고 나의 고양이 댓글 조회 항목에서도 개별 댓글 마다 고양이 이름이 들어가는 데 이떄 들어가는 고양이 이름은 컨텐츠에 들어가는 고양이 이름과 같도록 설계했다.문제는 처음에 컨텐츠 조회에서 등장하는 고양이와 댓글 조회에서 등장하는 고양이이름은 완전히 의미적으로 같음에도 불구하고 기능적으로 다르기 때문에 다른 필드 이름을 적는 실수를 저지르고 말았었다..그러나보니 나중에는 완전히 같은 뜻의 고양이 임에도 불구하고 다시 코드를 볼 때나 프론트 엔드 개발자가 다시 볼 때도 헷갈리는 문제가 생겨나고 말았다  프론트 개발자 : “같은 고양이 이름인데 왜 다른 이름을 사용했나요? 그 이유라도?… “즉 컨텐츠 조회에서 등장하나, 댓글 조회에서 등장하나 결국 같은 의미를 가지고 있기 때문에 같은 필드 네임을 적용하는 것이 맞다. 왜냐면 이렇게 되면 추가적으로 확인해야하는 번거러운 작업이 생략될 수 있다.아래를 보면첫번 째 고양이 컨텐츠 리스트 응답 데이터 중 하나이고 두번 째는 댓글 리스트 조회 응답 데이터 중 하나의 댓글을 가져왔다. 첫번 째는 필드이름(catName)만 봐도 고양이의 이름이라는 것을 유추할 수 있는 반면에 두번 째는 단순히 name 이라는 값이 댓글에 있는 고양이 이름인지, 아니면 다른 의미가 있는 것이 또 한번 추측해야하거나 문서를 확인해야하는 번거러움이 생기기 마련이다.따라서 이 경우 우측 name 필드 이름을 좌측과 같이 catName 으로 통일하는 것이 좋아보인다.{      \"catName\": \"바비\",      \"catAddress\": \"서울 마포구 망원동 415-31\",      \"catLat\": 37.582425,      \"catLon\": 126.985818,      \"catCommentCount\": 0,      \"catFollowerCount\": 0,      \"catCreatedAt\": \"2024-02-01T15:24:36\",      \"catUpdatedAt\": \"2024-02-01T15:24:36\",      \"catEmoji\": 1  }{    \"name\": \"바비\",    \"commentId\": 106,    \"commentDesc\": \"이 고양이 요즘 안보임... 너무 슬퍼.. 죽었나봐... \\n대신 다른 고양이가 오고있어\",    \"commentImageUris\": [],    \"createdAt\": \"2024-09-09T21:32:45\",    \"updatedAt\": \"2024-09-09T21:32:45\",    \"contentId\": 153,    \"commentLikeCount\": 0,    \"isCatCommentLiked\": false},깨달은 점사용되는 필드를 의미론적으로 똑같다면 같은 필드로 내려주는 것이 더 효율적일 것같다. 물론 이게 정답이라는 것은 아니다.만약 코드상으로 다른 필드를 적용해야 한다면 Jackson 라이브러리에 있는 @JsonProperty 를 사용해서 클라이언트 응답필드만 통일시키면 되기 때문에 큰 문제가 되지 않는다고 생각한다.",
            "content_html": "<h1 id=\"의미가-같다면-응답-필드-이름도-같도록-하자---나를-위해서-모두를-위해서\">의미가 같다면 응답 필드 이름도 같도록 하자! - 나를 위해서 모두를 위해서</h1><blockquote>  <p>같은 필드이고 그 의미가 다른 곳에서도 똑같이 적용되는 경우라면 왠만하면 통일되게 이름을 가져가는 것이 좋다고 생각이 든다.</p></blockquote><p>이냥저냥 토이프로젝트에서는 개별 고양이 컨텐츠를 상세 조회하거나 리스트 형태로 볼 수 있는 기능이 있다.</p><p>그리고 나의 고양이 댓글 조회 항목에서도 개별 댓글 마다 고양이 이름이 들어가는 데 이떄 들어가는 고양이 이름은 컨텐츠에 들어가는 고양이 이름과 같도록 설계했다.</p><p>문제는 처음에 컨텐츠 조회에서 등장하는 고양이와 댓글 조회에서 등장하는 고양이이름은 완전히 의미적으로 같음에도 불구하고 기능적으로 다르기 때문에 다른 필드 이름을 적는 실수를 저지르고 말았었다..</p><p>그러나보니 나중에는 완전히 같은 뜻의 고양이 임에도 불구하고 다시 코드를 볼 때나 프론트 엔드 개발자가 다시 볼 때도 헷갈리는 문제가 생겨나고 말았다</p><blockquote>  <p>프론트 개발자 : “같은 고양이 이름인데 왜 다른 이름을 사용했나요? 그 이유라도?… “</p></blockquote><p>즉 컨텐츠 조회에서 등장하나, 댓글 조회에서 등장하나 결국 같은 의미를 가지고 있기 때문에 같은 필드 네임을 적용하는 것이 맞다. 왜냐면 이렇게 되면 추가적으로 확인해야하는 번거러운 작업이 생략될 수 있다.</p><p>아래를 보면</p><p>첫번 째 고양이 컨텐츠 리스트 응답 데이터 중 하나이고 두번 째는 댓글 리스트 조회 응답 데이터 중 하나의 댓글을 가져왔다. 첫번 째는 필드이름(catName)만 봐도 고양이의 이름이라는 것을 유추할 수 있는 반면에 두번 째는 단순히 name 이라는 값이 댓글에 있는 고양이 이름인지, 아니면 다른 의미가 있는 것이 또 한번 추측해야하거나 문서를 확인해야하는 번거러움이 생기기 마련이다.따라서 이 경우 우측 <code class=\"language-html highlighter-rouge\">name</code> 필드 이름을 좌측과 같이 <code class=\"language-html highlighter-rouge\">catName</code> 으로 통일하는 것이 좋아보인다.</p><div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"p\">{</span><span class=\"w\">      </span><span class=\"nl\">\"catName\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"바비\"</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catAddress\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"서울 마포구 망원동 415-31\"</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catLat\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mf\">37.582425</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catLon\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mf\">126.985818</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catCommentCount\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catFollowerCount\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catCreatedAt\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2024-02-01T15:24:36\"</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catUpdatedAt\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2024-02-01T15:24:36\"</span><span class=\"p\">,</span><span class=\"w\">      </span><span class=\"nl\">\"catEmoji\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span></code></pre></div></div><div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"p\">{</span><span class=\"w\">    </span><span class=\"nl\">\"name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"바비\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"commentId\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">106</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"commentDesc\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"이 고양이 요즘 안보임... 너무 슬퍼.. 죽었나봐... </span><span class=\"se\">\\n</span><span class=\"s2\">대신 다른 고양이가 오고있어\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"commentImageUris\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[],</span><span class=\"w\">    </span><span class=\"nl\">\"createdAt\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2024-09-09T21:32:45\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"updatedAt\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2024-09-09T21:32:45\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"contentId\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">153</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"commentLikeCount\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"isCatCommentLiked\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"></span><span class=\"p\">}</span><span class=\"err\">,</span><span class=\"w\"></span></code></pre></div></div><h2 id=\"깨달은-점\">깨달은 점</h2><p>사용되는 필드를 의미론적으로 똑같다면 같은 필드로 내려주는 것이 더 효율적일 것같다. 물론 이게 정답이라는 것은 아니다.만약 코드상으로 다른 필드를 적용해야 한다면 Jackson 라이브러리에 있는 <code class=\"language-html highlighter-rouge\">@JsonProperty</code> 를 사용해서 클라이언트 응답필드만 통일시키면 되기 때문에 큰 문제가 되지 않는다고 생각한다.</p>",
            "url": "http://localhost:4000/2024/09/16/%EC%9D%98%EB%AF%B8%EA%B0%80-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EA%B0%99%EB%8B%A4%EB%A9%B4-%EC%9D%91%EB%8B%B5-%ED%95%84%EB%93%9C-%EC%9D%B4%EB%A6%84%EB%8F%84-%EA%B0%99%EA%B2%8C%ED%95%98%EC%9E%90",
            
            
            
            "tags": ["api","필드명","일관성","개발문화","협업"],
            
            "date_published": "2024-09-16T00:00:00+09:00",
            "date_modified": "2024-09-16T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/09/11/%EC%9E%98%EB%AA%BB-%EC%95%8C%EA%B3%A0-%EC%9E%88%EC%97%88%EB%8D%98-%EC%A7%81%EB%A0%AC%ED%99%94%EC%99%80-%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94",
            "title": "잘못 알고 있었던 직렬화와 역직렬화",
            "summary": "직렬화와 역직렬화의 개념을 바로잡습니다. 객체를 바이트코드뿐만 아니라 JSON, XML 등 저장하거나 전송할 수 있는 형태로 변환하는 과정과 그 반대 과정을 예시와 함께 설명합니다.",
            "content_text": "2023.12.16 - 잘못 알고 있었던 직렬화와 역직렬화JPA 를 사용하여 데이터베이스에 있는 데이터를 가져와 객체로 변환하는 과정에서 에러가 발생했다..  org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.time.Instant` from String ”2012-02-01”: Failed to deserialize java.time.Instant: (java.time.format.DateTimeParseException) Text ’2012-02-01’ could not be parsed at index 10직렬화와 역직렬화는 바이트코드에서 객체로의 정보교환만을 의미하는 것으로 알고 있었는 데 String 에서 Object 로의 변환 역시 역직렬화라고 표현하는 것을 보았다.알고보니 직렬화, 역직렬화는 그런 의미가 아니였다는 것을 깨달았고 관련된 내용을 정리해보았다.컴퓨터는 0 과 1 만 안다.사실 데이터에는 객체가 없다. 우리가 통신에서 주고 받는 데이터는 사실 바이트 코드로 대부분 0과 1로 이루어져 있다.객체는 사람들이 이해하기 쉽게 하기 위해 만든 추상적인 개념에 불과하다. 메모리에는 객체가 없다. 0과 1로 이루어진 데이터만 있을 뿐이다. 코드를 작성하는 에디터에 코드를 작성하고 저장버튼을 누르자. 그리고 다음날 저장된 파일을 에디터를 통해 열면 저장된 모습 그대로의 코드가 있을 것이다. 이건 어찌보면 당연한 거다. 저장을 했으니 말이다. 우리는 에디터를 통해 연 파일을 편집하고 있다고 생각하지만 이는 “직렬화” 라는 과정을 통해 실제 파일에 코드(실제로는 바이트코드)를 작성한 것이다. 해당 파일을 에디터로 여는 행위는 “역직렬화”라는 과정을 통해 파일에 있는 바이트 코드를 역직렬화를 통해 에디터가 읽어드릴 수 있는 형태로 바꾸게 된 것이다.직렬화와 역직렬화즉, 직렬화란 객체를 파일이나 통신할 수 있는 쉬운 형태로 변환하는 과정을 말한다. 통신할 수 있는 쉬운형태는 바이트코드가 될 수도 있고 JSON 이나 XML 같이 규격화된 또 다른 통신 형태로 정해놓은 형태일 수도 있다. 역직렬화는 직렬화의 반대로, 직렬화된 정보를 다시 원래대로 객체의 형태로 되돌리는 것을 의미한다.즉, 바이트코드에서 오브젝트로, 오브젝트에서 바이트코드로 정보의 형태를 바꾸는 것만이 직렬화, 역직렬화를 뜻하는 것이 아니였다.객체를 JSON, XML, 파일 이 모든 것이 해당된다.### 파일을 주고 받는 것 또한 직렬화와 역직렬화가 사용된다.A 라는 컴퓨터와 B 라는 컴퓨터가 서로 파일을 주고 받는 다고 가정해보자.A 와 B는 각자 컴퓨터 스팩도 다르고 사용하는 프로그래밍 언어도 다르지만, 0과 1이라는 바이트 코드를 전기적 신호로 바꾸어 회선을 통해 전달받을 수 있다.그렇기 때문에 전달하고자 하는 파일을 먼저 0과 1이라고 하는 바이트코드로 “직렬화” 한다. 0과 1의 바이트코드로 변환된 데이터는 회선을 통해 전기적인 신호로 바뀌어 전달되게 된다. 파일 데이터를 전기적신호를 0과1의 바이트코드로 전달받은 다른 컴퓨터는 이를 “역직렬화”를 통해 바이트데이터를 실제로 존재하는 오브젝트(파일)로 바꾸어 전달받는다.  ### JSON 데이터 주고 받기또 다른 예로 브라우저에서 서버와 통신을 주고 받을 때 주로 JSON 형태의 데이터를 주고 받는다. 오브젝트 파일에서 JSON 파일로 직렬화 하여 전송하고 다운로드 받은 JSON 파일에서 역직렬화 한다.  ### 이제는 이해되는 에러메시지   Cannot deserialize value of type `java.time.Instant` from String ”2012-02-01”: Failed to deserialize java.time.Instant: (java.time.format.DateTimeParseException) Text ’2012-02-01’ could not be parsed at index 10이 오류 메시지는 java.time.Instant 객체로의 역직렬화 중에 발생한 문제를 설명하고 있다. java.time.Instant는 날짜와 시간을 표현하는 자바의 클래스 중 하나인데, 주어진 문자열 “2012-02-01”을 Instant 객체로 변환할 수 없다는 것을 나타낸다. 즉, “역직렬화” 할 수 없다는 것이다. java.time.Instant는 ISO 8601 형식에 맞춰진 문자열을 사용하여 날짜와 시간을 나타내고 있다. 그렇기 때문에 역직렬화의 대상이 되는 문자열은 반드시 “YYYY-MM-DDTHH:MM:SSZ”와 같은 형식이어야 한다. 그러나 “2012-02-01”은 시간 정보가 없는 날짜 정보만을 가지고 있기 때문에 Instant로 역직렬화할 때 오류가 발생했던 것이다. (사실 이러한 문제는 JSON 을 Object 로 변환 할 때도 빈번하게 일어나는 문제이다. 보통 이런 경우 JSON 을 Object 로 직렬,역질렬화를 도와주는 라이브러리를 사용하게 되는 데 위의 문제와 마찬가지로 JSON 에 포맷에 맞지 않는 경우 오브젝트 변환 시 “역직렬화”에 실패했다는 메시지를 자주 볼 수 있을 것이다.)자바 객체 &lt;-&gt; 파일Person 이라는 객체를 생성한 후 객체를 직렬화 하여 파일에 저장합니다. 이후 파일에 저장된 객체를 역직렬화 하여 읽어옵니다.import java.io.*;// Serializable 인터페이스를 구현하여 직렬화 가능하도록 만듭니다.class Person implements Serializable {    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}public class SerializationExample {    public static void main(String[] args) {        // Person 객체 생성        Person person = new Person(\"Alice\", 30);        // 객체를 직렬화하여 파일에 저장        try (FileOutputStream fileOut = new FileOutputStream(\"serialized_person.ser\");             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {                        out.writeObject(person);            System.out.println(\"Person 객체를 직렬화하여 저장했습니다.\");        } catch (IOException e) {            e.printStackTrace();        }        // 파일에서 객체를 역직렬화하여 읽어옴        Person loadedPerson = null;        try (FileInputStream fileIn = new FileInputStream(\"serialized_person.ser\");             ObjectInputStream in = new ObjectInputStream(fileIn)) {                        loadedPerson = (Person) in.readObject();            System.out.println(\"Person 객체를 역직렬화했습니다.\");        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }        // 역직렬화된 Person 객체 정보 출력        if (loadedPerson != null) {            System.out.println(\"이름: \" + loadedPerson.getName());            System.out.println(\"나이: \" + loadedPerson.getAge());        }    }요약오브젝트를 직렬화하고 역직렬화하는 데 사용되는 포맷을 굉장히 많다. 하지만 핵심은 추상적인 오브젝트를 구체적이고 저장가능한 형태로 정보를 바꾸어 주는 역할을 한다는 것이다.참고https://www.youtube.com/watch?v=qrQZOPZmt0whttps://www.boardinfinity.com/blog/serialization-in-java/",
            "content_html": "<h1 id=\"20231216---잘못-알고-있었던-직렬화와-역직렬화\">2023.12.16 - 잘못 알고 있었던 직렬화와 역직렬화</h1><p>JPA 를 사용하여 데이터베이스에 있는 데이터를 가져와 객체로 변환하는 과정에서 에러가 발생했다..</p><blockquote>  <p>org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.time.Instant` from String ”2012-02-01”: Failed to deserialize java.time.Instant: (java.time.format.DateTimeParseException) Text ’2012-02-01’ could not be parsed at index 10</p></blockquote><p>직렬화와 역직렬화는 바이트코드에서 객체로의 정보교환만을 의미하는 것으로 알고 있었는 데 String 에서 Object 로의 변환 역시 역직렬화라고 표현하는 것을 보았다.<br />알고보니 직렬화, 역직렬화는 그런 의미가 아니였다는 것을 깨달았고 관련된 내용을 정리해보았다.</p><h3 id=\"컴퓨터는-0-과-1-만-안다\">컴퓨터는 0 과 1 만 안다.</h3><p>사실 데이터에는 객체가 없다. 우리가 통신에서 주고 받는 데이터는 사실 바이트 코드로 대부분 0과 1로 이루어져 있다.</p><p>객체는 사람들이 이해하기 쉽게 하기 위해 만든 추상적인 개념에 불과하다. 메모리에는 객체가 없다. 0과 1로 이루어진 데이터만 있을 뿐이다. </p><p>코드를 작성하는 에디터에 코드를 작성하고 저장버튼을 누르자. 그리고 다음날 저장된 파일을 에디터를 통해 열면 저장된 모습 그대로의 코드가 있을 것이다. 이건 어찌보면 당연한 거다. 저장을 했으니 말이다. </p><p>우리는 에디터를 통해 연 파일을 편집하고 있다고 생각하지만 이는 “직렬화” 라는 과정을 통해 실제 파일에 코드(실제로는 바이트코드)를 작성한 것이다. 해당 파일을 에디터로 여는 행위는 “역직렬화”라는 과정을 통해 파일에 있는 바이트 코드를 역직렬화를 통해 에디터가 읽어드릴 수 있는 형태로 바꾸게 된 것이다.</p><h3 id=\"직렬화와-역직렬화\">직렬화와 역직렬화</h3><p>즉, <strong>직렬화</strong>란 객체를 파일이나 통신할 수 있는 쉬운 형태로 변환하는 과정을 말한다. 통신할 수 있는 쉬운형태는 바이트코드가 될 수도 있고 JSON 이나 XML 같이 규격화된 또 다른 통신 형태로 정해놓은 형태일 수도 있다. </p><p><strong>역직렬화</strong>는 직렬화의 반대로, 직렬화된 정보를 다시 원래대로 객체의 형태로 되돌리는 것을 의미한다.</p><p><strong>즉, 바이트코드에서 오브젝트로, 오브젝트에서 바이트코드로 정보의 형태를 바꾸는 것만이 직렬화, 역직렬화를 뜻하는 것이 아니였다.</strong></p><p><strong>객체를 JSON, XML, 파일 이 모든 것이 해당된다.</strong></p><p>### <br />파일을 주고 받는 것 또한 직렬화와 역직렬화가 사용된다.</p><p>A 라는 컴퓨터와 B 라는 컴퓨터가 서로 파일을 주고 받는 다고 가정해보자.</p><p>A 와 B는 각자 컴퓨터 스팩도 다르고 사용하는 프로그래밍 언어도 다르지만, 0과 1이라는 바이트 코드를 전기적 신호로 바꾸어 회선을 통해 전달받을 수 있다.</p><p>그렇기 때문에 전달하고자 하는 파일을 먼저 0과 1이라고 하는 바이트코드로 “직렬화” 한다. 0과 1의 바이트코드로 변환된 데이터는 회선을 통해 전기적인 신호로 바뀌어 전달되게 된다. </p><p>파일 데이터를 전기적신호를 0과1의 바이트코드로 전달받은 다른 컴퓨터는 이를 “역직렬화”를 통해 바이트데이터를 실제로 존재하는 오브젝트(파일)로 바꾸어 전달받는다.</p><p align=\"center\">  <img width=\"600\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/docs/images/se_de_1.png\" /></p><p>### <br />JSON 데이터 주고 받기</p><p>또 다른 예로 브라우저에서 서버와 통신을 주고 받을 때 주로 JSON 형태의 데이터를 주고 받는다. </p><p>오브젝트 파일에서 JSON 파일로 직렬화 하여 전송하고 다운로드 받은 JSON 파일에서 역직렬화 한다.</p><p align=\"center\">  <img width=\"600\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/docs/images/se_de.png\" /></p><p>### <br />이제는 이해되는 에러메시지</p><blockquote>  <p> Cannot deserialize value of type `java.time.Instant` from String ”2012-02-01”: Failed to deserialize java.time.Instant: (java.time.format.DateTimeParseException) Text ’2012-02-01’ could not be parsed at index 10</p></blockquote><p>이 오류 메시지는 java.time.Instant 객체로의 역직렬화 중에 발생한 문제를 설명하고 있다. java.time.Instant는 날짜와 시간을 표현하는 자바의 클래스 중 하나인데, 주어진 <strong>문자열 “2012-02-01”</strong>을 <strong>Instant 객체로 변환할 수 없다는 것</strong>을 나타낸다. 즉, “역직렬화” 할 수 없다는 것이다. </p><p><strong>java.time.Instant는 ISO 8601 형식에 맞춰진 문자열</strong>을 사용하여 날짜와 시간을 나타내고 있다. 그렇기 때문에 역직렬화의 대상이 되는 문자열은 반드시 “YYYY-MM-DDTHH:MM:SSZ”와 같은 형식이어야 한다. 그러나 “2012-02-01”은 시간 정보가 없는 날짜 정보만을 가지고 있기 때문에 <strong>Instant로 역직렬화</strong>할 때 오류가 발생했던 것이다. </p><p>(사실 이러한 문제는 JSON 을 Object 로 변환 할 때도 빈번하게 일어나는 문제이다. 보통 이런 경우 JSON 을 Object 로 직렬,역질렬화를 도와주는 라이브러리를 사용하게 되는 데 위의 문제와 마찬가지로 JSON 에 포맷에 맞지 않는 경우 오브젝트 변환 시 “역직렬화”에 실패했다는 메시지를 자주 볼 수 있을 것이다.)</p><h3 id=\"자바-객체---파일\">자바 객체 &lt;-&gt; 파일</h3><p>Person 이라는 객체를 생성한 후 객체를 직렬화 하여 파일에 저장합니다. 이후 파일에 저장된 객체를 역직렬화 하여 읽어옵니다.</p><div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code>import java.io.*;// Serializable 인터페이스를 구현하여 직렬화 가능하도록 만듭니다.class Person implements Serializable {    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}public class SerializationExample {    public static void main(String[] args) {        // Person 객체 생성        Person person = new Person(\"Alice\", 30);        // 객체를 직렬화하여 파일에 저장        try (FileOutputStream fileOut = new FileOutputStream(\"serialized_person.ser\");             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {                        out.writeObject(person);            System.out.println(\"Person 객체를 직렬화하여 저장했습니다.\");        } catch (IOException e) {            e.printStackTrace();        }        // 파일에서 객체를 역직렬화하여 읽어옴        Person loadedPerson = null;        try (FileInputStream fileIn = new FileInputStream(\"serialized_person.ser\");             ObjectInputStream in = new ObjectInputStream(fileIn)) {                        loadedPerson = (Person) in.readObject();            System.out.println(\"Person 객체를 역직렬화했습니다.\");        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }        // 역직렬화된 Person 객체 정보 출력        if (loadedPerson != null) {            System.out.println(\"이름: \" + loadedPerson.getName());            System.out.println(\"나이: \" + loadedPerson.getAge());        }    }</code></pre></div></div><h3 id=\"요약\">요약</h3><p>오브젝트를 직렬화하고 역직렬화하는 데 사용되는 포맷을 굉장히 많다. 하지만 핵심은 <strong>추상적인 오브젝트를 구체적이고 저장가능한 형태로 정보를 바꾸어 주는 역할</strong>을 한다는 것이다.</p><h2 id=\"참고\">참고</h2><p><a href=\"https://www.youtube.com/watch?v=qrQZOPZmt0w\">https://www.youtube.com/watch?v=qrQZOPZmt0w</a></p><p><a href=\"https://www.boardinfinity.com/blog/serialization-in-java/\">https://www.boardinfinity.com/blog/serialization-in-java/</a></p>",
            "url": "http://localhost:4000/2024/09/11/%EC%9E%98%EB%AA%BB-%EC%95%8C%EA%B3%A0-%EC%9E%88%EC%97%88%EB%8D%98-%EC%A7%81%EB%A0%AC%ED%99%94%EC%99%80-%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94",
            
            
            
            "tags": ["직렬화","역직렬화","json","serialization","deserialization","java"],
            
            "date_published": "2024-09-11T00:00:00+09:00",
            "date_modified": "2024-09-11T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/09/11/%EB%B9%85%ED%85%8C%ED%81%AC-%EC%88%98%EC%84%9D-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-%EC%9D%BC-%EC%BD%94%EB%94%A9-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
            "title": "빅테크 수석 개발자가 알려주는 일(코딩) 잘하는 방법",
            "summary": "유튜브 영상을 보고 빅테크 수석 개발자가 알려주는 업무 추정 방법에 대해 정리한 글입니다. 섣부른 대답 대신 충분히 조사하고, 예상 시간에 3배를 곱하여 신뢰를 잃지 않는 방법을 제안합니다.",
            "content_text": "2024.09.11 - 빅테크 수석 개발자가 알려주는 일(코딩) 잘하는 방법  우연히 유튜브를 보는 와중에 흥미로운 썸네일을 보고 도저히 지나칠 수 없어 시청했는 데 너무나 인상 깊고 공감되는 이야기가 많아 잊고 싶지 않아서 성장일기에 적어보았다.  이 일 얼마나 걸릴 것 같아요?결론은 이렇게 질문이 오면 바로 대답할 필요가 없다. 상황마다 다르겠지만 제가 조금 더 조사해보고 오늘 밤 혹은 퇴근 전에 알려주겠다 라고 하는 게 좋다.PM 이나 상급자가 이렇게 질문을 했을 때, 나의 반응은 두 가지 중 하나였다.  대답을 망설이거나 이러면 보통 상대방에서 “하루안에 가능하죠? 내일까지 되죠?” 라고 질문이 들어오면 “내일까지는 되죠” 라고 대답해버리고 만다.  깊게 고민하지 않고 어림 짐작으로 대답했었다.(나중에 보면 굉장히 타이트한 일정이였다.)사실 지금 생각해보면 썩 좋은 대답은 아니라고 생각이 든다. 왜냐하면      1번의 경우 일을 끝내지 못했을 때 대한 나에 대한 기대치와 신뢰가 떨어질 수 있다. 매니징하는 입장에서도 하루면 간단한 일이라고 생각했을 텐데 끝나지 않은 모습을 보면 기대치가 낮아질 수 밖에 없다. 어떻게 보면 상대방에 대한 나의 기대를 올리기 위해 시작한 말이 나중에는 오히려 상대방의 기대치를 낮추게 하는 결과를 가져오게 된다.        2번의 경우 프로패셔녈하지 못하다. 상대방은 내가 대답하는 것에 따라서 추가적 인 일정을 생각할 수 있는 데 내가 잘 못 대답해서 상대방의 일정도 망가지게 된다. 이건 상대방을 배려하는 모습이 아니다.커리어를 처음 시작하는 입장에서는 의욕이 앞서기 때문에 스스로 어떻게든 해결할 수도 있는 데 이 경우에는 별로 좋은 해결방법이 아니다.    이한결 엔지니어“만약 잘 모르겠으면 그 자리에서 바로 답하지 말고 퇴근하기 전까지 파악해서 알려주겠다 라고 말한 뒤 예상되는 시간에 3배정도 걸릴 것 같다 라고 말하면 좋다”  “기대치를 낮추고 파이룰(3.14)를 활용해라(예상되는 업무 시간에 * 3 을 하는 것”곱하기 3이라니 너무 많은 거 아니야?만약 상급 엔지니어가 3일이 아니라 하루 정도 걸릴 것 같은데? 라고 한다면? 보통 나의 경우도 하루만에 할 수 있을 것 같다고 대답했던 것 같다.왠지 시니어가 그렇게 말한다면 그런  이유가 있지 않을까? 라고 생각하면서 수긍하면서 시간을 줄여가면서 일을 했던 것 같다. 지금 생각해보면 왜 그렇게 시간이 걸릴 수 밖에 없는 지 상급자에게 물어보지 않은 나를 반성하게 되었다.머리속으로는 이해하지만 실제로 저렇게 행동할 수 있을지는 확신하지는 않지만 .. 😂참조https://www.youtube.com/watch?v=J3Fd5HjWsvE",
            "content_html": "<h1 id=\"20240911---빅테크-수석-개발자가-알려주는-일코딩-잘하는-방법\">2024.09.11 - 빅테크 수석 개발자가 알려주는 일(코딩) 잘하는 방법</h1><blockquote>  <p>우연히 유튜브를 보는 와중에 흥미로운 썸네일을 보고 도저히 지나칠 수 없어 시청했는 데 너무나 인상 깊고 공감되는 이야기가 많아 잊고 싶지 않아서 성장일기에 적어보았다.</p></blockquote><p align=\"center\">  <img width=\"600\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"https://github.com/user-attachments/assets/5843db49-8bbe-4776-b5a2-119b2654ff15\" /></p><h2 id=\"이-일-얼마나-걸릴-것-같아요\">이 일 얼마나 걸릴 것 같아요?</h2><p>결론은 이렇게 질문이 오면 바로 대답할 필요가 없다. 상황마다 다르겠지만 제가 조금 더 조사해보고 오늘 밤 혹은 퇴근 전에 알려주겠다 라고 하는 게 좋다.PM 이나 상급자가 이렇게 질문을 했을 때, 나의 반응은 두 가지 중 하나였다.</p><ol>  <li>대답을 망설이거나 이러면 보통 상대방에서 “하루안에 가능하죠? 내일까지 되죠?” 라고 질문이 들어오면 “내일까지는 되죠” 라고 대답해버리고 만다.</li>  <li>깊게 고민하지 않고 어림 짐작으로 대답했었다.(나중에 보면 굉장히 타이트한 일정이였다.)</li></ol><p>사실 지금 생각해보면 썩 좋은 대답은 아니라고 생각이 든다. 왜냐하면</p><ul>  <li>    <p>1번의 경우 일을 끝내지 못했을 때 대한 <strong>나에 대한 기대치와 신뢰가 떨어질 수 있다</strong>. 매니징하는 입장에서도 하루면 간단한 일이라고 생각했을 텐데 끝나지 않은 모습을 보면 기대치가 낮아질 수 밖에 없다. 어떻게 보면 상대방에 대한 나의 기대를 올리기 위해 시작한 말이 나중에는 오히려 상대방의 기대치를 낮추게 하는 결과를 가져오게 된다.</p>  </li>  <li>    <p>2번의 경우 프로패셔녈하지 못하다. 상대방은 내가 대답하는 것에 따라서 추가적 인 일정을 생각할 수 있는 데 내가 잘 못 대답해서 상대방의 일정도 망가지게 된다. 이건 <strong>상대방을 배려하는 모습이 아니다</strong>.커리어를 처음 시작하는 입장에서는 의욕이 앞서기 때문에 스스로 어떻게든 해결할 수도 있는 데 이 경우에는 별로 좋은 해결방법이 아니다.</p>  </li></ul><blockquote>  <p>이한결 엔지니어<br />“만약 잘 모르겠으면 그 자리에서 바로 답하지 말고 퇴근하기 전까지 파악해서 알려주겠다 라고 말한 뒤 예상되는 시간에 3배정도 걸릴 것 같다 라고 말하면 좋다”</p></blockquote><blockquote>  <p>“기대치를 낮추고 파이룰(3.14)를 활용해라(예상되는 업무 시간에 * 3 을 하는 것”</p></blockquote><p>곱하기 3이라니 너무 많은 거 아니야?만약 상급 엔지니어가 3일이 아니라 하루 정도 걸릴 것 같은데? 라고 한다면? 보통 나의 경우도 하루만에 할 수 있을 것 같다고 대답했던 것 같다.왠지 시니어가 그렇게 말한다면 그런  이유가 있지 않을까? 라고 생각하면서 수긍하면서 시간을 줄여가면서 일을 했던 것 같다. 지금 생각해보면 왜 그렇게 시간이 걸릴 수 밖에 없는 지 상급자에게 물어보지 않은 나를 반성하게 되었다.</p><p>머리속으로는 이해하지만 실제로 저렇게 행동할 수 있을지는 확신하지는 않지만 .. 😂</p><h3 id=\"참조\">참조</h3><hr /><p>https://www.youtube.com/watch?v=J3Fd5HjWsvE</p>",
            "url": "http://localhost:4000/2024/09/11/%EB%B9%85%ED%85%8C%ED%81%AC-%EC%88%98%EC%84%9D-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-%EC%9D%BC-%EC%BD%94%EB%94%A9-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
            
            
            
            "tags": ["일잘하는법","업무추정","개발자","커리어","성장"],
            
            "date_published": "2024-09-11T00:00:00+09:00",
            "date_modified": "2024-09-11T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/09/11/2024-dlca-tech-tree-con-%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%9B%84%EA%B8%B0",
            "title": "2024 DLCA Tech-Tree CON 컨퍼런스 후기 - 첫 컨퍼런스 방문 😄",
            "summary": "2024 DLCA Tech-Tree CON 컨퍼런스에 처음으로 참석한 후기입니다. 테오님, 이동욱(향로)님, 이장원(페퍼톤스)님의 세션을 통해 개발자로서의 성장과 커리어에 대한 깊은 인사이트를 얻을 수 있었습니다.",
            "content_text": "2024 DLCA Tech-Tree CON 컨퍼런스 후기 - 첫 컨퍼런스 방문 😄    세션 목록들이다. 가수분도 나온다고 하셔서 놀랐다   내가 가고 싶은 테크 컨퍼런스를 찾던 와중 마음에 드는 세션이 보여 바로 신청했다.특히 미래의 개발자의 커리어를 어떻게 쌓으면 좋을까를 고민했었는 데 마침 나에게 딱 맞는 주제가 보여서 고민 없이 신청했다.물론 라이브 다시보기로도 볼 수 있지만 직접 가서 현장의 분위기를 느껴보고 싶었다. 현장에서는 바로 앞자리에 앉을 수 있어서 너무 좋았다 😃특히 테오님과 이동욱(향로)님 같은 경우에는 너무 유명하셔서 꼭 직접 보고 싶은 마음도 있었다. 하지만 면접 때문에 테오님 세션을 처음부터 듣지 못한 게 너무 아쉬웠다.배운 것  &lt;img width=70% alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/IMG_5306.JPG\"&gt;&gt; _**개발만 하고 싶은 게 다른 걸 자꾸 시켜요? 여러분 그런 것도 다 개발이예요. 코드만 작성하고 그런 것만 개발인 게 아니예요. 회의하고 고민하고 등등 모두 다 개발하고 있는 거예요**_  - _유용태(테오)_&gt; &gt; _**제어할 수 없는 것에 힘쓰는 것이 아니라 내가 제어할 수 것에 힘을 쓰자.**_  - _이동욱(향로)_&gt; &gt; _**맹귀우목(盲龜遇木) 에 나오는 거북이 처럼 파도가 쳐서 떠내려 간다고 해도 열심히 노력하다 보면 결국에는 섬에 도착하게 되있어요.**_ - _이장원(페퍼톤스)_비록 상황이 좋지 않더라도, 그 상황 속에서 내가 제어할 수 있는 것과 없는 것을 찾아서, 제어할 수 있다면 그 부분에서 최선을 다해 성과를 내는 것이 맞다.만약 내가 어떤 회사를 갔는데 사수가 없다면, 개발 환경이 좋지 못하다면, 온보딩도 제대로 되어있지 않다면, 그렇다면 먼저 제어할 수 있는 것과 제어할 수 없는 것을 나누어서이렇게 성장 할 수 있는 환경이 되지 못한다면 내가 스스로 나서서 스터디를 모집하거나 좋은 문화를 전파시켜 볼 수 있을 것이다.  (실제 동욱님도 개발자들이 전부 퇴사하고 스스로 좋은 개발문화를 만들려고 노력했고 동료들에게 먼저 전파하려고 하셨다.)    &lt;img src=\"/assets/images/IMG_5309.jpg\" width=30%  align=\"center\"&gt;    &lt;img src=\"/assets/images/IMG_5322.jpg\" width=30%  align=\"center\"&gt;",
            "content_html": "<h2 id=\"2024-dlca-tech-tree-con-컨퍼런스-후기---첫-컨퍼런스-방문-\">2024 DLCA Tech-Tree CON 컨퍼런스 후기 - 첫 컨퍼런스 방문 😄</h2><p align=\"center\">  <img width=\"500\" alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/tech_conference_index.png\" /><br />  <em>세션 목록들이다. 가수분도 나온다고 하셔서 놀랐다</em>   </p><p>내가 가고 싶은 테크 컨퍼런스를 찾던 와중 마음에 드는 세션이 보여 바로 신청했다.특히 미래의 개발자의 커리어를 어떻게 쌓으면 좋을까를 고민했었는 데 마침 나에게 딱 맞는 주제가 보여서 고민 없이 신청했다.</p><p><del>물론 라이브 다시보기로도 볼 수 있지만 직접 가서 현장의 분위기를 느껴보고 싶었다. 현장에서는 바로 앞자리에 앉을 수 있어서 너무 좋았다 😃</del></p><p>특히 테오님과 이동욱(향로)님 같은 경우에는 너무 유명하셔서 꼭 직접 보고 싶은 마음도 있었다. 하지만 면접 때문에 테오님 세션을 처음부터 듣지 못한 게 너무 아쉬웠다.</p><h3 id=\"배운-것\">배운 것</h3><p align=\"center\">  &lt;img width=70% alt=\"스크린샷 2024-09-11 오후 8 05 07\" src=\"/assets/images/IMG_5306.JPG\"&gt;<br /><!-- ~~용태님 세션은 중간부터 참여해서 전부 듣지는 못했지만~~ 인상깊었던 말들을 가져와봤다.  -->&gt; _**개발만 하고 싶은 게 다른 걸 자꾸 시켜요? 여러분 그런 것도 다 개발이예요. 코드만 작성하고 그런 것만 개발인 게 아니예요. 회의하고 고민하고 등등 모두 다 개발하고 있는 거예요**_ <br /> - _유용태(테오)_&gt; <br /><br />&gt; _**제어할 수 없는 것에 힘쓰는 것이 아니라 내가 제어할 수 것에 힘을 쓰자.**_ <br /> - _이동욱(향로)_&gt; <br /><br />&gt; _**맹귀우목(盲龜遇木) 에 나오는 거북이 처럼 파도가 쳐서 떠내려 간다고 해도 열심히 노력하다 보면 결국에는 섬에 도착하게 되있어요.**_ <br />- _이장원(페퍼톤스)_비록 상황이 좋지 않더라도, 그 상황 속에서 내가 제어할 수 있는 것과 없는 것을 찾아서, 제어할 수 있다면 그 부분에서 최선을 다해 성과를 내는 것이 맞다.만약 내가 어떤 회사를 갔는데 사수가 없다면, 개발 환경이 좋지 못하다면, 온보딩도 제대로 되어있지 않다면, 그렇다면 먼저 제어할 수 있는 것과 제어할 수 없는 것을 나누어서이렇게 성장 할 수 있는 환경이 되지 못한다면 내가 스스로 나서서 스터디를 모집하거나 좋은 문화를 전파시켜 볼 수 있을 것이다.  (실제 동욱님도 개발자들이 전부 퇴사하고 스스로 좋은 개발문화를 만들려고 노력했고 동료들에게 먼저 전파하려고 하셨다.)<div align=\"center\">    &lt;img src=\"/assets/images/IMG_5309.jpg\" width=30%  align=\"center\"&gt;    &lt;img src=\"/assets/images/IMG_5322.jpg\" width=30%  align=\"center\"&gt;</div></p>",
            "url": "http://localhost:4000/2024/09/11/2024-dlca-tech-tree-con-%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%9B%84%EA%B8%B0",
            
            
            
            "tags": ["컨퍼런스","dlca","tech-tree-con","후기","개발자","커리어"],
            
            "date_published": "2024-09-11T00:00:00+09:00",
            "date_modified": "2024-09-11T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0",
            "title": "[Spring] @RestControllerAdvice에서 body 로깅으로 남기기",
            "summary": "@RestControllerAdvice에서 예외 발생 시 HttpServletRequest의 body를 로깅하려 할 때 발생하는 문제를 다룹니다. InputStream이 한 번만 읽을 수 있는 이유를 설명하고, ContentCachingRequestWrapper와 커스텀 필터를 사용하여 이 문제를 해결하는 방법을 제시합니다.",
            "content_text": "2024.05.11 -  🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md사건의 발단현재 진행하고 있는 프로젝트에서는 @RestControllerAdvice 를 이용하여 예외를 전역으로 처리하고 있다.예외가 났을 때 어떤 요청값이 들어와서 예외가 발생했는 지 로그로 남기고 싶어서 request 의 body 를 읽고 싶었으나 아무런 값이 없는 문제가 발생했다.@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler {  @ExceptionHandler(HotelkingException.class)  public ResponseEntity&lt;ApiResponse&lt;ErrorContent&gt;&gt; handleHotelkingException(      HotelkingException e,      HttpServletRequest request  ){    ErrorCode ec = e.getErrorCode();String body = StreamUtils.copyToString(request.getInputStream(), StandardCharsets.UTF_8);log.error(\"body = {}\", body); // 슬프게도 아무것도 안나온다.    return ResponseEntity.status(ec.getHttpStatus()).body(ApiResponse.error(ErrorContent.from(ec)));  }  @ExceptionHandler(HttpMessageNotReadableException.class)  public ResponseEntity&lt;ApiResponse&lt;ErrorContent&gt;&gt; handleHttpMessageNotReadableException(HttpMessageNotReadableException e, HttpServletRequest request) {    ErrorCode ec = ErrorCode.NOT_READABLE;    printLog(request, ec);    return ResponseEntity        .status(ErrorCode.NOT_READABLE.getHttpStatus())        .body(ApiResponse.error(ErrorContent.from(ec)));  }}HttpServletRequest 에서 다시 한번 InputStream 을 이용하여 body 를 읽으려고 했지만 아무것도 읽을 수 없었다.HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.  The spring-web module contains the HttpMessageConverter interface for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for concurrency, in the RestClient) and on the server side (for concurrency, in Spring MVC REST controllers).Spring MVC 는 Servlet API 기반으로 만들어졌다. Spring MVC 에서는 Dispatcher Servlet 이 그 역할을 담당하고 있다.Http 요청을 다룰 때 HttpServletRequest 에서 요청 body 를 읽을 때 getInputStream() 그리고 getReader() 메서드를 제공한다.이러한 각 메소드는 동일한 InputStream 을 사용하기 때문에 InputStream을 한 번 읽으면 다시 읽을 수 없는 문제가 있다.ContentCachingRequestWrapperContentCachingRequestWrapper 는 생성자로 받은 HttpServeltRequest 를 input stream 과 reader 로 부터 모든 HttpServletRequest 컨텐츠를 캐시하는 HttpServlerRequest Wrapper 클래스이다.캐시한 content 는 byte array 형태로 다시 얻을 수 있다.얻을 때는 getContentAsByteArray() 를 통해 다시 얻을 수 있다.중요한 건 요청 컨텐츠가 consumed 되지 않았다면, 컨텐츠는 캐시되지 않는다.public class ContentCachingRequestWrapper extends HttpServletRequestWrapper {private final FastByteArrayOutputStream cachedContent;public ContentCachingRequestWrapper(HttpServletRequest request) {\t\tsuper(request);\t\t\t\t// 캐시 하는 부분\t\tint contentLength = request.getContentLength();\t\t\t\t// content 가 있는 경우 캐시한다.\t\tthis.cachedContent = (contentLength &gt; 0) ? new FastByteArrayOutputStream(contentLength) : new FastByteArrayOutputStream();\t\tthis.contentCacheLimit = null;\t}\t\t...\t\t// 캐시한 컨텐츠를 가져온다.\tpublic byte[] getContentAsByteArray() {\t\treturn this.cachedContent.toByteArray();\t}}엄청 특이한 건 없다.다만 FastByteArrayOutputStream 이라고 하는 OutputStream 을 extend 하여 새롭게 만들어 사용하고 있다. 문서에서는 ByteArrayOutputStream 의 대안으로 나왔다고 한다.참고로 AbstractRequestLoggingFilter 에서도 위의 ContentCachingRequestWrapper 가 사용된다.적용Custom Filter 를 만들어 기존 HttpServletRequest 를 캐싱할 수 있도록 들어온 HttpServletRequest 를 이용하여 ContentCachingRequestWrapper 객체를 만든 후 doFilter를 호출합니다.@Componentpublic class CachingFilter extends OncePerRequestFilter {  @Override  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,      FilterChain filterChain) throws ServletException, IOException {    filterChain.doFilter(new ContentCachingRequestWrapper(request), response);  }}참고  https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-message-conversion",
            "content_html": "<h1 id=\"20240511-----restcontrolleradvice-에서-body-로깅으로-남기기md\">2024.05.11 -  🌱 @RestControllerAdvice 에서 body 로깅으로 남기기.md</h1><h2 id=\"사건의-발단\">사건의 발단</h2><p>현재 진행하고 있는 프로젝트에서는 @RestControllerAdvice 를 이용하여 예외를 전역으로 처리하고 있다.<br />예외가 났을 때 어떤 요청값이 들어와서 예외가 발생했는 지 로그로 남기고 싶어서 request 의 body 를 읽고 싶었으나 아무런 값이 없는 문제가 발생했다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"nd\">@Slf4j</span><span class=\"nd\">@RestControllerAdvice</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">GlobalExceptionHandler</span> <span class=\"o\">{</span>  <span class=\"nd\">@ExceptionHandler</span><span class=\"o\">(</span><span class=\"nc\">HotelkingException</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span>  <span class=\"kd\">public</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">&lt;</span><span class=\"nc\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nc\">ErrorContent</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">handleHotelkingException</span><span class=\"o\">(</span>      <span class=\"nc\">HotelkingException</span> <span class=\"n\">e</span><span class=\"o\">,</span>      <span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span>  <span class=\"o\">){</span>    <span class=\"nc\">ErrorCode</span> <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getErrorCode</span><span class=\"o\">();</span><span class=\"nc\">String</span> <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"nc\">StreamUtils</span><span class=\"o\">.</span><span class=\"na\">copyToString</span><span class=\"o\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"na\">getInputStream</span><span class=\"o\">(),</span> <span class=\"nc\">StandardCharsets</span><span class=\"o\">.</span><span class=\"na\">UTF_8</span><span class=\"o\">);</span><span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"body = {}\"</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">);</span> <span class=\"c1\">// 슬프게도 아무것도 안나온다.</span>    <span class=\"k\">return</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">.</span><span class=\"na\">status</span><span class=\"o\">(</span><span class=\"n\">ec</span><span class=\"o\">.</span><span class=\"na\">getHttpStatus</span><span class=\"o\">()).</span><span class=\"na\">body</span><span class=\"o\">(</span><span class=\"nc\">ApiResponse</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"nc\">ErrorContent</span><span class=\"o\">.</span><span class=\"na\">from</span><span class=\"o\">(</span><span class=\"n\">ec</span><span class=\"o\">)));</span>  <span class=\"o\">}</span>  <span class=\"nd\">@ExceptionHandler</span><span class=\"o\">(</span><span class=\"nc\">HttpMessageNotReadableException</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span>  <span class=\"kd\">public</span> <span class=\"nc\">ResponseEntity</span><span class=\"o\">&lt;</span><span class=\"nc\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nc\">ErrorContent</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">handleHttpMessageNotReadableException</span><span class=\"o\">(</span><span class=\"nc\">HttpMessageNotReadableException</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"nc\">ErrorCode</span> <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"nc\">ErrorCode</span><span class=\"o\">.</span><span class=\"na\">NOT_READABLE</span><span class=\"o\">;</span>    <span class=\"n\">printLog</span><span class=\"o\">(</span><span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"n\">ec</span><span class=\"o\">);</span>    <span class=\"k\">return</span> <span class=\"nc\">ResponseEntity</span>        <span class=\"o\">.</span><span class=\"na\">status</span><span class=\"o\">(</span><span class=\"nc\">ErrorCode</span><span class=\"o\">.</span><span class=\"na\">NOT_READABLE</span><span class=\"o\">.</span><span class=\"na\">getHttpStatus</span><span class=\"o\">())</span>        <span class=\"o\">.</span><span class=\"na\">body</span><span class=\"o\">(</span><span class=\"nc\">ApiResponse</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"nc\">ErrorContent</span><span class=\"o\">.</span><span class=\"na\">from</span><span class=\"o\">(</span><span class=\"n\">ec</span><span class=\"o\">)));</span>  <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>HttpServletRequest 에서 다시 한번 InputStream 을 이용하여 body 를 읽으려고 했지만 아무것도 읽을 수 없었다.</p><h2 id=\"httpservletrequest-에서-값을-읽을-때는-내부적으로-inputstream-을-사용한다\">HttpServletRequest 에서 값을 읽을 때는 내부적으로 InputStream 을 사용한다.</h2><blockquote>  <p>The spring-web module contains the HttpMessageConverter interface for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for concurrency, in the RestClient) and on the server side (for concurrency, in Spring MVC REST controllers).</p></blockquote><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/bc215933-2cc6-43a4-9a7f-36dc13766dee/image.png\" alt=\"\" /></p><p>Spring MVC 는 Servlet API 기반으로 만들어졌다. Spring MVC 에서는 Dispatcher Servlet 이 그 역할을 담당하고 있다.Http 요청을 다룰 때 HttpServletRequest 에서 요청 body 를 읽을 때 <code class=\"language-html highlighter-rouge\">getInputStream()</code> 그리고 <code class=\"language-html highlighter-rouge\">getReader()</code> 메서드를 제공한다.이러한 각 메소드는 동일한 InputStream 을 사용하기 때문에 InputStream을 한 번 읽으면 다시 읽을 수 없는 문제가 있다.</p><h2 id=\"contentcachingrequestwrapper\">ContentCachingRequestWrapper</h2><p><code class=\"language-html highlighter-rouge\">ContentCachingRequestWrapper</code> 는 생성자로 받은 HttpServeltRequest 를 input stream 과 reader 로 부터 모든 HttpServletRequest 컨텐츠를 캐시하는 HttpServlerRequest Wrapper 클래스이다.</p><p>캐시한 content 는 byte array 형태로 다시 얻을 수 있다.</p><p>얻을 때는 <code class=\"language-html highlighter-rouge\">getContentAsByteArray()</code> 를 통해 다시 얻을 수 있다.</p><p>중요한 건 요청 컨텐츠가 consumed 되지 않았다면, 컨텐츠는 캐시되지 않는다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ContentCachingRequestWrapper</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServletRequestWrapper</span> <span class=\"o\">{</span><span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">FastByteArrayOutputStream</span> <span class=\"n\">cachedContent</span><span class=\"o\">;</span><span class=\"kd\">public</span> <span class=\"nf\">ContentCachingRequestWrapper</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">)</span> <span class=\"o\">{</span>\t\t<span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">request</span><span class=\"o\">);</span>\t\t\t\t<span class=\"c1\">// 캐시 하는 부분</span>\t\t<span class=\"kt\">int</span> <span class=\"n\">contentLength</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"na\">getContentLength</span><span class=\"o\">();</span>\t\t\t\t<span class=\"c1\">// content 가 있는 경우 캐시한다.</span>\t\t<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cachedContent</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">contentLength</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"k\">new</span> <span class=\"nc\">FastByteArrayOutputStream</span><span class=\"o\">(</span><span class=\"n\">contentLength</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nc\">FastByteArrayOutputStream</span><span class=\"o\">();</span>\t\t<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">contentCacheLimit</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\t<span class=\"o\">}</span>\t\t<span class=\"o\">...</span>\t\t<span class=\"c1\">// 캐시한 컨텐츠를 가져온다.</span>\t<span class=\"kd\">public</span> <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"nf\">getContentAsByteArray</span><span class=\"o\">()</span> <span class=\"o\">{</span>\t\t<span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cachedContent</span><span class=\"o\">.</span><span class=\"na\">toByteArray</span><span class=\"o\">();</span>\t<span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>엄청 특이한 건 없다.</p><p>다만 <code class=\"language-html highlighter-rouge\">FastByteArrayOutputStream</code> 이라고 하는 OutputStream 을 extend 하여 새롭게 만들어 사용하고 있다. 문서에서는 ByteArrayOutputStream 의 대안으로 나왔다고 한다.</p><p>참고로 <code class=\"language-html highlighter-rouge\">AbstractRequestLoggingFilter</code> 에서도 위의 <code class=\"language-html highlighter-rouge\">ContentCachingRequestWrapper</code> 가 사용된다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/8eb4fafc-4f37-4855-9bb4-8a8bc838a0d5/image.png\" alt=\"\" /></p><h2 id=\"적용\">적용</h2><p>Custom Filter 를 만들어 기존 HttpServletRequest 를 캐싱할 수 있도록 들어온 HttpServletRequest 를 이용하여 ContentCachingRequestWrapper 객체를 만든 후 doFilter를 호출합니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"nd\">@Component</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CachingFilter</span> <span class=\"kd\">extends</span> <span class=\"nc\">OncePerRequestFilter</span> <span class=\"o\">{</span>  <span class=\"nd\">@Override</span>  <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doFilterInternal</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">,</span>      <span class=\"nc\">FilterChain</span> <span class=\"n\">filterChain</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">ServletException</span><span class=\"o\">,</span> <span class=\"nc\">IOException</span> <span class=\"o\">{</span>    <span class=\"n\">filterChain</span><span class=\"o\">.</span><span class=\"na\">doFilter</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">ContentCachingRequestWrapper</span><span class=\"o\">(</span><span class=\"n\">request</span><span class=\"o\">),</span> <span class=\"n\">response</span><span class=\"o\">);</span>  <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><h3 id=\"참고\">참고</h3><ul>  <li>https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-message-conversion</li></ul>",
            "url": "http://localhost:4000/2024/05/11/spring-restcontrolleradvice-%EC%97%90%EC%84%9C-body-%EB%A1%9C%EA%B9%85%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0",
            
            
            
            "tags": ["spring","spring boot","restcontrolleradvice","filter","contentcachingrequestwrapper","logging","exception handling"],
            
            "date_published": "2024-05-11T00:00:00+09:00",
            "date_modified": "2024-05-11T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1",
            "title": "다시 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성",
            "summary": "분산락을 이용한 동시성 제어 코드 작성 중 발생한 문제를 통해 영속성 컨텍스트와 DB 격리 레벨의 중요성을 다시 한번 깨달았습니다. 문제 원인 분석과 해결 과정을 공유합니다.",
            "content_text": "다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성  분산락(Distributed Lock) 관련 코드를 작성하고 테스트하던 중, 예상치 못한 결과가 계속 발생했습니다. 원인을 파고들어 보니, 제가 간과하고 있던 중요한 개념들이 있었습니다. 이 글에서는 그 과정에서 얻은 교훈을 공유하고자 합니다.결론부터 말하자면, 문제의 원인은 다음과 같았습니다.  영속성 컨텍스트를 제대로 이해하지 못했던 것  Lock의 범위를 잘못 설정했던 것  (가장 중요) MySQL InnoDB 엔진의 기본 격리 레벨(Isolation Level)을 고려하지 않았던 것원인 분석 및 해결 과정문제 상황: 데이터 불일치문제의 코드는 다음과 같았습니다. reserve 메서드는 roomId를 받아 해당 방의 재고(RoomStock)를 감소시키는 로직입니다. 동시성 문제를 해결하기 위해 분산락을 사용했습니다.@Transactionalpublic String reserve(long roomId) {    try {        // 1. 락 획득 시도        Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1);        if (lock == null || lock == 0) {            log.info(\"락 획득 실패\");            return \"fail\";        }        log.info(\"락 획득!\");        // 2. 재고 조회 및 감소        RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow();        roomStock.decrease();    } catch (RuntimeException e) {        log.warn(e.getMessage());    } finally {        // 3. 락 해제        roomStockRepository.releaseLock(String.valueOf(roomId));        log.info(\"락 해제!\");    }    return \"success\";}이 코드의 가장 큰 문제는 영속성 컨텍스트에 있었습니다. 락을 획득한 후 findRoomStockByRoomId 메서드로 RoomStock 객체를 조회할 때, JPA는 먼저 영속성 컨텍스트(1차 캐시)를 확인합니다. 만약 이전에 같은 roomId로 조회한 RoomStock 객체가 영속성 컨텍스트에 존재한다면, 데이터베이스를 다시 조회하지 않고 캐시에 있는 객체를 그대로 반환합니다.이로 인해 다른 스레드가 이미 재고를 변경하고 커밋했더라도, 현재 스레드는 변경 전의 데이터를 가지고 decrease() 메서드를 호출하게 되어 데이터 불일치가 발생합니다.시도 1: 락 해제 시점 변경처음에는 락을 너무 빨리 해제해서 문제가 발생한다고 생각했습니다. commit이 되기 전에 다른 스레드가 락을 획득하고, 아직 변경사항이 반영되지 않은 데이터를 읽어간다고 추측했습니다. 하지만 MySQL의 general_log를 확인해 본 결과, 그런 상황은 발생하지 않았습니다.진짜 원인: REPEATABLE READ 격리 레벨문제의 핵심은 MySQL InnoDB 스토리지 엔진의 기본 격리 레벨인 REPEATABLE READ에 있었습니다. 이 격리 레벨에서는 트랜잭션이 시작될 때의 데이터 스냅샷을 만들어, 트랜잭션이 진행되는 동안에는 해당 스냅샷의 데이터만 읽습니다. 따라서 다른 트랜잭션이 데이터를 변경하고 커밋하더라도, 현재 트랜잭션은 그 변경사항을 볼 수 없습니다.위 로그에서 1961번 트랜잭션이 커밋한 이후에 1962번 트랜잭션이 데이터를 조회했지만, 1962번 트랜잭션은 자신이 시작될 때의 스냅샷을 기준으로 데이터를 읽었기 때문에 변경 전의 데이터를 가져온 것입니다.해결 방안이 문제를 해결하기 위해 다음과 같이 코드를 수정했습니다.  락 획득 후, 새로운 트랜잭션에서 재고 조회 및 감소 로직 실행  @Transactional(propagation = Propagation.REQUIRES_NEW) 옵션을 사용하여 decrease 메서드가 항상 새로운 트랜잭션에서 실행되도록 강제합니다. 이렇게 하면 decrease 메서드가 호출될 때마다 새로운 스냅샷을 생성하여 최신 데이터를 읽어올 수 있습니다.// ReservationService.java@Service@Slf4jpublic class ReservationService {    private final RoomStockRepository roomStockRepository;    private final RoomStockService roomStockService;    // ... 생성자    @Transactional    public String reserve(long roomId) {        try {            Long lock = roomStockRepository.getLock(String.valueOf(roomId), 1);            if (lock == null || lock == 0) {                log.info(\"락 획득 실패\");                return \"fail\";            }            log.info(\"락 획득!\");            // 별도의 트랜잭션을 가진 서비스 메서드 호출            roomStockService.decrease(roomId);        } catch (RuntimeException e) {            log.warn(e.getMessage());        } finally {            roomStockRepository.releaseLock(String.valueOf(roomId));            log.info(\"락 해제!\");        }        return \"success\";    }}// RoomStockService.java@Slf4j@Servicepublic class RoomStockService {    private final RoomStockRepository roomStockRepository;    // ... 생성자    @Transactional(propagation = Propagation.REQUIRES_NEW)    public void decrease(long roomId) {        try {            RoomStock roomStock = roomStockRepository.findRoomStockByRoomId(roomId).orElseThrow();            roomStock.decrease();            // 변경사항을 즉시 DB에 반영            roomStockRepository.saveAndFlush(roomStock);        } catch (RuntimeException e) {            log.warn(e.getMessage());        }    }}추가 고려사항: 영속성 컨텍스트 스코프JPA의 영속성 컨텍스트는 기본적으로 트랜잭션 스코프(Transaction-Scoped)를 가집니다. 즉, 영속성 컨텍스트의 생명주기는 트랜잭션의 생명주기와 동일합니다. 트랜잭션이 시작될 때 생성되고, 트랜잭션이 끝날 때(커밋 또는 롤백) 사라집니다.@PersistenceContext 어노테이션의 type 속성을 통해 확장 스코프(Extended-Scoped)를 사용할 수도 있습니다. 확장 스코프는 여러 트랜잭션에 걸쳐 영속성 컨텍스트를 유지할 수 있게 해주지만, 명시적으로 flush를 호출해야 변경사항이 반영되므로 주의해서 사용해야 합니다.@Repeatable(PersistenceContexts.class)@Target({TYPE, METHOD, FIELD})@Retention(RUNTIME)public @interface PersistenceContext {   // ...   /**    * (Optional) Specifies whether a transaction-scoped persistence context     * or an extended persistence context is to be used.    */   PersistenceContextType type() default PersistenceContextType.TRANSACTION;      // ...}이번 경험을 통해 동시성 문제를 다룰 때는 코드 로직뿐만 아니라, JPA의 영속성 컨텍스트와 데이터베이스의 격리 레벨까지 깊이 있게 이해하는 것이 얼마나 중요한지 다시 한번 깨닫게 되었습니다.",
            "content_html": "<h1 id=\"다시금-깨닫는-영속성-컨텍스트와-db-격리-레벨의-중요성\">다시금 깨닫는 영속성 컨텍스트와 DB 격리 레벨의 중요성</h1><blockquote>  <p>분산락(Distributed Lock) 관련 코드를 작성하고 테스트하던 중, 예상치 못한 결과가 계속 발생했습니다. 원인을 파고들어 보니, 제가 간과하고 있던 중요한 개념들이 있었습니다. 이 글에서는 그 과정에서 얻은 교훈을 공유하고자 합니다.</p></blockquote><p>결론부터 말하자면, 문제의 원인은 다음과 같았습니다.</p><ol>  <li><strong>영속성 컨텍스트</strong>를 제대로 이해하지 못했던 것</li>  <li><strong>Lock의 범위</strong>를 잘못 설정했던 것</li>  <li>(가장 중요) MySQL <strong>InnoDB 엔진의 기본 격리 레벨(Isolation Level)</strong>을 고려하지 않았던 것</li></ol><p><img src=\"https://www.baeldung.com/wp-content/uploads/2016/10/Hibernate-Persistence-Context-2.png\" alt=\"영속성 컨텍스트\" /></p><h2 id=\"원인-분석-및-해결-과정\">원인 분석 및 해결 과정</h2><h3 id=\"문제-상황-데이터-불일치\">문제 상황: 데이터 불일치</h3><p>문제의 코드는 다음과 같았습니다. <code class=\"language-html highlighter-rouge\">reserve</code> 메서드는 <code class=\"language-html highlighter-rouge\">roomId</code>를 받아 해당 방의 재고(<code class=\"language-html highlighter-rouge\">RoomStock</code>)를 감소시키는 로직입니다. 동시성 문제를 해결하기 위해 분산락을 사용했습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"nd\">@Transactional</span><span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">reserve</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">roomId</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">try</span> <span class=\"o\">{</span>        <span class=\"c1\">// 1. 락 획득 시도</span>        <span class=\"nc\">Long</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">getLock</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">),</span> <span class=\"mi\">1</span><span class=\"o\">);</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lock</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">lock</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 획득 실패\"</span><span class=\"o\">);</span>            <span class=\"k\">return</span> <span class=\"s\">\"fail\"</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 획득!\"</span><span class=\"o\">);</span>        <span class=\"c1\">// 2. 재고 조회 및 감소</span>        <span class=\"nc\">RoomStock</span> <span class=\"n\">roomStock</span> <span class=\"o\">=</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">findRoomStockByRoomId</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">).</span><span class=\"na\">orElseThrow</span><span class=\"o\">();</span>        <span class=\"n\">roomStock</span><span class=\"o\">.</span><span class=\"na\">decrease</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">RuntimeException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getMessage</span><span class=\"o\">());</span>    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>        <span class=\"c1\">// 3. 락 해제</span>        <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">releaseLock</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">));</span>        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 해제!\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"s\">\"success\"</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p>이 코드의 가장 큰 문제는 <strong>영속성 컨텍스트</strong>에 있었습니다. 락을 획득한 후 <code class=\"language-html highlighter-rouge\">findRoomStockByRoomId</code> 메서드로 <code class=\"language-html highlighter-rouge\">RoomStock</code> 객체를 조회할 때, JPA는 먼저 영속성 컨텍스트(1차 캐시)를 확인합니다. 만약 이전에 같은 <code class=\"language-html highlighter-rouge\">roomId</code>로 조회한 <code class=\"language-html highlighter-rouge\">RoomStock</code> 객체가 영속성 컨텍스트에 존재한다면, <strong>데이터베이스를 다시 조회하지 않고 캐시에 있는 객체를 그대로 반환</strong>합니다.</p><p>이로 인해 다른 스레드가 이미 재고를 변경하고 커밋했더라도, 현재 스레드는 변경 전의 데이터를 가지고 <code class=\"language-html highlighter-rouge\">decrease()</code> 메서드를 호출하게 되어 <strong>데이터 불일치</strong>가 발생합니다.</p><h3 id=\"시도-1-락-해제-시점-변경\">시도 1: 락 해제 시점 변경</h3><p>처음에는 락을 너무 빨리 해제해서 문제가 발생한다고 생각했습니다. <code class=\"language-html highlighter-rouge\">commit</code>이 되기 전에 다른 스레드가 락을 획득하고, 아직 변경사항이 반영되지 않은 데이터를 읽어간다고 추측했습니다. 하지만 MySQL의 <code class=\"language-html highlighter-rouge\">general_log</code>를 확인해 본 결과, 그런 상황은 발생하지 않았습니다.</p><p><img src=\"images/img.png\" alt=\"MySQL general_log\" /></p><h3 id=\"진짜-원인-repeatable-read-격리-레벨\">진짜 원인: REPEATABLE READ 격리 레벨</h3><p>문제의 핵심은 MySQL InnoDB 스토리지 엔진의 기본 격리 레벨인 <strong>REPEATABLE READ</strong>에 있었습니다. 이 격리 레벨에서는 <strong>트랜잭션이 시작될 때의 데이터 스냅샷</strong>을 만들어, 트랜잭션이 진행되는 동안에는 해당 스냅샷의 데이터만 읽습니다. 따라서 다른 트랜잭션이 데이터를 변경하고 커밋하더라도, 현재 트랜잭션은 그 변경사항을 볼 수 없습니다.</p><p>위 로그에서 <code class=\"language-html highlighter-rouge\">1961</code>번 트랜잭션이 커밋한 이후에 <code class=\"language-html highlighter-rouge\">1962</code>번 트랜잭션이 데이터를 조회했지만, <code class=\"language-html highlighter-rouge\">1962</code>번 트랜잭션은 자신이 시작될 때의 스냅샷을 기준으로 데이터를 읽었기 때문에 변경 전의 데이터를 가져온 것입니다.</p><h2 id=\"해결-방안\">해결 방안</h2><p>이 문제를 해결하기 위해 다음과 같이 코드를 수정했습니다.</p><ol>  <li><strong>락 획득 후, 새로운 트랜잭션에서 재고 조회 및 감소 로직 실행</strong></li>  <li><code class=\"language-html highlighter-rouge\">@Transactional(propagation = Propagation.REQUIRES_NEW)</code> 옵션을 사용하여 <code class=\"language-html highlighter-rouge\">decrease</code> 메서드가 항상 새로운 트랜잭션에서 실행되도록 강제합니다. 이렇게 하면 <code class=\"language-html highlighter-rouge\">decrease</code> 메서드가 호출될 때마다 새로운 스냅샷을 생성하여 최신 데이터를 읽어올 수 있습니다.</li></ol><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"c1\">// ReservationService.java</span><span class=\"nd\">@Service</span><span class=\"nd\">@Slf4j</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ReservationService</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">RoomStockRepository</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">RoomStockService</span> <span class=\"n\">roomStockService</span><span class=\"o\">;</span>    <span class=\"c1\">// ... 생성자</span>    <span class=\"nd\">@Transactional</span>    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">reserve</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">roomId</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">Long</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">getLock</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">),</span> <span class=\"mi\">1</span><span class=\"o\">);</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lock</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">lock</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 획득 실패\"</span><span class=\"o\">);</span>                <span class=\"k\">return</span> <span class=\"s\">\"fail\"</span><span class=\"o\">;</span>            <span class=\"o\">}</span>            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 획득!\"</span><span class=\"o\">);</span>            <span class=\"c1\">// 별도의 트랜잭션을 가진 서비스 메서드 호출</span>            <span class=\"n\">roomStockService</span><span class=\"o\">.</span><span class=\"na\">decrease</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">);</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">RuntimeException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getMessage</span><span class=\"o\">());</span>        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>            <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">releaseLock</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">));</span>            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">\"락 해제!\"</span><span class=\"o\">);</span>        <span class=\"o\">}</span>        <span class=\"k\">return</span> <span class=\"s\">\"success\"</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"c1\">// RoomStockService.java</span><span class=\"nd\">@Slf4j</span><span class=\"nd\">@Service</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">RoomStockService</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">RoomStockRepository</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">;</span>    <span class=\"c1\">// ... 생성자</span>    <span class=\"nd\">@Transactional</span><span class=\"o\">(</span><span class=\"n\">propagation</span> <span class=\"o\">=</span> <span class=\"nc\">Propagation</span><span class=\"o\">.</span><span class=\"na\">REQUIRES_NEW</span><span class=\"o\">)</span>    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">decrease</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">roomId</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">RoomStock</span> <span class=\"n\">roomStock</span> <span class=\"o\">=</span> <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">findRoomStockByRoomId</span><span class=\"o\">(</span><span class=\"n\">roomId</span><span class=\"o\">).</span><span class=\"na\">orElseThrow</span><span class=\"o\">();</span>            <span class=\"n\">roomStock</span><span class=\"o\">.</span><span class=\"na\">decrease</span><span class=\"o\">();</span>            <span class=\"c1\">// 변경사항을 즉시 DB에 반영</span>            <span class=\"n\">roomStockRepository</span><span class=\"o\">.</span><span class=\"na\">saveAndFlush</span><span class=\"o\">(</span><span class=\"n\">roomStock</span><span class=\"o\">);</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">RuntimeException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getMessage</span><span class=\"o\">());</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><h2 id=\"추가-고려사항-영속성-컨텍스트-스코프\">추가 고려사항: 영속성 컨텍스트 스코프</h2><p>JPA의 영속성 컨텍스트는 기본적으로 <strong>트랜잭션 스코프(Transaction-Scoped)</strong>를 가집니다. 즉, 영속성 컨텍스트의 생명주기는 트랜잭션의 생명주기와 동일합니다. 트랜잭션이 시작될 때 생성되고, 트랜잭션이 끝날 때(커밋 또는 롤백) 사라집니다.</p><p><code class=\"language-html highlighter-rouge\">@PersistenceContext</code> 어노테이션의 <code class=\"language-html highlighter-rouge\">type</code> 속성을 통해 <strong>확장 스코프(Extended-Scoped)</strong>를 사용할 수도 있습니다. 확장 스코프는 여러 트랜잭션에 걸쳐 영속성 컨텍스트를 유지할 수 있게 해주지만, 명시적으로 <code class=\"language-html highlighter-rouge\">flush</code>를 호출해야 변경사항이 반영되므로 주의해서 사용해야 합니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"nd\">@Repeatable</span><span class=\"o\">(</span><span class=\"nc\">PersistenceContexts</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span><span class=\"nd\">@Target</span><span class=\"o\">({</span><span class=\"no\">TYPE</span><span class=\"o\">,</span> <span class=\"no\">METHOD</span><span class=\"o\">,</span> <span class=\"no\">FIELD</span><span class=\"o\">})</span><span class=\"nd\">@Retention</span><span class=\"o\">(</span><span class=\"no\">RUNTIME</span><span class=\"o\">)</span><span class=\"kd\">public</span> <span class=\"nd\">@interface</span> <span class=\"nc\">PersistenceContext</span> <span class=\"o\">{</span>   <span class=\"c1\">// ...</span>   <span class=\"cm\">/**    * (Optional) Specifies whether a transaction-scoped persistence context     * or an extended persistence context is to be used.    */</span>   <span class=\"nc\">PersistenceContextType</span> <span class=\"nf\">type</span><span class=\"o\">()</span> <span class=\"k\">default</span> <span class=\"nc\">PersistenceContextType</span><span class=\"o\">.</span><span class=\"na\">TRANSACTION</span><span class=\"o\">;</span>      <span class=\"c1\">// ...</span><span class=\"o\">}</span></code></pre></div></div><p>이번 경험을 통해 동시성 문제를 다룰 때는 코드 로직뿐만 아니라, JPA의 영속성 컨텍스트와 데이터베이스의 격리 레벨까지 깊이 있게 이해하는 것이 얼마나 중요한지 다시 한번 깨닫게 되었습니다.</p>",
            "url": "http://localhost:4000/2024/02/21/%EB%8B%A4%EC%8B%9C-%EA%B9%A8%EB%8B%AB%EB%8A%94-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1",
            
            
            
            "tags": ["jpa","영속성 컨텍스트","db 격리 레벨","동시성","분산락","spring"],
            
            "date_published": "2024-02-21T00:00:00+09:00",
            "date_modified": "2024-02-21T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/02/21/lamda-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-%EC%A0%81%EC%9A%A9%EA%B8%B0",
            "title": "AWS Lambda를 활용한 이미지 리사이징 적용기",
            "summary": "S3, Lambda, API Gateway를 이용하여 이미지 업로드 및 리사이징 프로세스를 개선한 경험을 공유합니다. Presigned URL을 활용하여 보안을 강화하고, 서버의 부담을 줄이는 방법을 자세히 설명합니다.",
            "content_text": "2024.02.21 - AWS Lambda 를 활용한 이미지 리사이징 적용기들어가면서현재 진행하고 있는 프로젝트에는 이미지 업로드 기능이 있다. 클라이언트가 API 키를 이용하여 Cloudnary 에 이미지를 업로드 한 후 업로드 된 이미지 URI와 포스팅하려고 하는 내용과 함께 서버에 등록하는 방식이다. 하지만 이러한 방식은 다소 문제가 일어날 요지가 있어 이미지 업로드 과정을 개선해보았다.문제클라이언트 (프론트엔드) 가 미리 정의된 API 키를 이용하여 이미지서버 (Cloudnary) 에 이미지를 바로 저장하고 있다. 즉, 클라이언트가 이미지 저장에 대한 모든 권한을 가지고 있는 셈이다. 이때 API 키는 클라이언트에 노출되어있기때문에 KEY가 탈취된다면 언제든지 누군가 사용해서 이미지를 업로드 할 수 있는 문제가 생긴다.또한 현재 프로젝트에서 사용되는 이미지 사이즈는 최대 500px 임에도 불구하고 클라이언트로 부터 원본 이미지를 저장한 후 저장된 원본이미지를 그대로 사용하고 있다. 원본 사이즈 크기를 사용할 필요가 없음에도 불구하고 불필요하게 이미지 다운로드 용량을 낭비하고 있다.  보안적인 문제로 인해 클라이언트가 아닌 서버에서 이미지 저장을 처리해야 한다.  불필요한 네트워크 낭비를 방지하고자 요청할 때는 리사이징된 작은 사이즈의 이미지를 요청할 수 있도록 한다.해결      S3 이미지 저장에 대한 권한은 일시간동안만 사용가능한 업로드 용 Presigned URI 를 만들어 해당 URI를 통해 클라이언트가 이미지를 업로드 할 수 있게 하여 클라이언트가 업로드에 대한 모든 권한을 가질 수 없도록 하였다.        API 서버에서 하지 않아도 외부에서 리사이징 작업을 할 수 있기 위해서 S3 와 Lambda 를 이용하여 이미지 리사이징에 대한 처리를 하였다.  위와 같은 해결은 쉽게 나오진 않았다. 아래의 상황을 고려한 후 최종적으로 S3 와 Lambda, API Gateway 를 이용한 이미지 처리방식을 채택하였다.방안 1먼저 처음 생각한 이미지 처리 방식이다.직관적으로 생각한 방식이다.클라이언트가 이미지(최대 3개까지) multipart 방식으로 API 서버로 이미지를 업로드 하면, 서버는 S3에 권한을 가진 IAM 사용자의 AccessKey 와 SecretKey 를 이용하여 S3에 이미지를 저장한다.저장 후에는 저장된 S3 이미지 URI를 저장하려고 하는 컨텐츠 정보와 함께 데이터베이스에 저장한다.이 과정이 모두 완료되면 클라이언트에 성공 응답(200)을 한다.이렇게 한다면 이미지 저장에 대한 권한은 서버에 있기 때문에 1번에 대한 문제가 해결된다.또한 이미지 리사이징도 서버에서 하기 때문에 이 또한 문제가 될 상황은 없어 보인다.하지만 클라이언트의 이미지 요청 이후 2, 3, 4번 의 응답이 늦어지면 늦어질 수록 최종 클라이언트로 가는 응답 역시 늦어질 수 밖에 없다.그래서 이미지 리사이징 처리를 다른 곳에서 할 수 있는 방안을 생각해보았다.(2번과 3번의 과정을 비동기 요청으로 할 경우 위와 같은 문제를 해결할 수 있을 것 같다. 하지만 비동기는 아직 익숙치 않기 때문에 그보다는 다른 방법으로 해결하기로 했다. 추후에 시간이 된다면 비동기에 대한 부분도 다루어 보도록 하겠다)방안 2방안 1에 비해서는 구조가 복잡해 보인다. S3 이외에 Lambda 가 추가되었다.크게 두 가지의 FLOW가 존재한다.FLOW 1  클라이언트가 API서버로 이미지를 전송한다.  API 서버는 클라이언트로 부터 받은 이미지를 S3에 업로드 한다.  S3에 저장된 이미지 URI를 요청받는 컨텐츠와 함께 DB에 저장한다.  저장이 완료되면 클라이언트로 성공 응답(200) 을 보낸다.FLOW 2  S3에 이미지가 저장될 경우 이미지 리사이징을 담당하는 Lambda 함수로 Events를 보낸다.  Lambda 함수는 저장된 S3 이미지를 가져와 리사이징 작업을 한다.  리사이징 작업이 끝나면 크기별로 S3에 저장한다.참고로 FLOW 1 번과 FLOW 2은 별개로 진행된다.그리고 서버는 더 이상 이미지 리사이징 작업을 하지 않아도 된다. 최소한 리사이징 작업으로 인해 응답이 지연되지는 않는다. 하지만 S3에 이미지를 저장하는 건 여전히 API 서버가 담당하고 있다.방안 3방안 2보다 훨씬 복잡해졌다.방안2와 다른 점은 이미지저장을 더 이상 서버에서 하지 않는다. 대신 서버에서는 이미지를 저장할 수 있는 Presigned URI 를 생성하도록 S3에 요청한다.클라이언트는 이 Presigned URI를 이용해 서버가 아닌 바로 S3에 이미지를 업로드한다. 이후 S3에 업로드 되어 진행되는 리사이징 과정은 Lambda 를 통해 이루어진다. (방안 2와 같다)이후에는 Presigned URI 와 함께 추가 저장할 컨텐츠 정보를 서버로 전달합니다. 서버는 이미지 URI 를 저장한 후 클라이언트로 성공응답(200)을 보낸다.Presigned URI 의 경우 20분의 유효시간을 정했다.public class AWSPresignedUriService(){    private final AmazonS3 s3;        public AWSPresignedUriService(final AmazonS3 s3){        this.s3 = s3;    }    \tpublic String generatePresignedUri(String bucketName, String filePath){\t\tCalendar calendar = Calendar.getInstance();        calendar.setTime(new Date());        calendar.add(Calendar.MINUTE, 20); // 20분의 유효시간        return s3.generatePresigenedUri(bucketName, filePath, calendar.getTime(), HttpMethod.PUT).toString();\t}}20분의 유효시간이 끝나면 발급받은 Presigned URI 는 더 이상 사용할 수 없다.이제 서버가 이미지와 관련된 작업을 하는 건 S3에 Presigned URI 를 생성하기 위해 요청하는 작업만 있다.하지만 아직까지 이미지 처리와 관련해서 서버에서 프로그래밍 방식으로 Presigned URI를 생성하기 때문에 버킷 이름이나 파일 경로를 바꾸기 위해서는 서버 코드를 수정해야하는 단점이 존재한다.이미지와 관련된 작업은 사실 크게 비지니스 로직에 벗어나지 않음에도 불구하고 새로운 Presigend URI를 만들기 위해 API 서버 코드를 수정하여 배포하고 싶지는 않았다.방안 4이미지 리사이징 Lambda 와 더불어 Presigned URI 를 생성하는 Lambda 를 추가한 후 API Gateway 를 만들어 Lambda 함수를 API 형태로 노출시킨다.이로써 더 이상 API 서버에서는 이미지와 관련된 작업을 더 이상 하지 않게 되었다.또한 API Gateway 는 “수신한 API 호출 1백만 건 무료” 이기 때문에 우리 프로젝트에 사용하기에는 충분했다.만약 새로운 Bucket 에 대해서 Presigned URI 을 생성하고 싶다면 서버코드는 전혀 건들이지 않고 Lambda 함수만 수정하면 되는 장점이 생겼다. 이제 더 이상 이미지와 관련된 작업은 API 서버에서 생각하지 않아도 되었다.개발과정S3와 CloudWatch 의 권한을 가진 새로운 정책 생성하기리사이징을 담당하는 람다 함수와 이미지 업로드 가능하도록 하는 Presigned URI 를 만들기 위해서는 S3에 권한이 있어야한다.이미지 리사이징을 담당하는 람다 함수의 경우 S3 로 부터 Event 를 받아 S3 이미지를 조회한 후 이미지 사이즈 별로 S3에 업로드 해야하기 때문에 S3 GET, PUT 에 대해 허용권한이 있어야한다.IAM &gt; 정책 &gt; 정책 생성 으로 들어가 필요한 권한을 설정해준다.참고로 Cloudwatch 에서 람다 이벤트에 대한 로그가 수집될 수 있도록 필요한 권한 역시 설정한다.정책을 생성했으니 이제 Role(역할)을 생성해야한다. Lambda 와 같은 AWS 리소스에 일시적으로 권한을 부여할 수 있는 데 Role 을 부여함으로써 가능하다. 또한 Role은 Policy와 연결되어야 사용할 수 있기 때문에 필요한 Lambda 가 사용할 역할을 만든다.역할은 IAM &gt; 역할 &gt; 역할 생성 에 들어가서 만들면 된다.권한 추가 항목에서는 아까 만든 정책(위의 스샷에서는 안보이지만 정책이름을 LambdaS3Policy 로 하였다) 선택한다.역할 이름을 넣고 역할생성 버튼을 눌러 역할을 생성한다.Lambda 함수 생성하기Lambda &gt; 함수 &gt; 함수 생성에 들어가 Lambda 함수를 생성한다.이때 Lambda 생성시 실행역할을 아까 만들었던 LambdaS3Role 로 선택한다. (먼저 Lambda 를 만들고 추구 Lambda &gt; 구성 &gt; 권한 &gt; 편집 항목에서 원하는 역할로 바꿀 수 있기 때문에 무엇을 먼저 만들지는 상관없다.)이미지 리사이징 코드import {S3Client, GetObjectCommand, PutObjectCommand} from '@aws-sdk/client-s3';import {Readable} from 'stream';import sharp from 'sharp';import util from 'util';import convert from 'heic-convert';const s3 = new S3Client({region: 'ap-northeast-2'});const widths = [80, 500];function parseBucketInfoFromEvent(event) {  console.log(`Event: ${JSON.stringify(event)}`);  const record = event.Records[0].s3;  const srcBucket = record.bucket.name;  const srcKey = decodeURIComponent(record.object.key.replace(/\\+/g, \" \"));  return {    srcBucket,    srcKey,    dstBucket: `${srcBucket}-resized`,    dstKey: `${srcKey}.jpg`,  };}// Fetch object from S3async function fetchObject({bucket, key}) {  const params = {Bucket: bucket, Key: key};  try {    const response = await s3.send(new GetObjectCommand(params));    const contentType = response.ContentType;    console.log(`ContentType: ${contentType}`);    if (!(response.Body instanceof Readable)) {      throw new Error('Expected a stream in the response body');    }    return response;  } catch (error) {    console.error(`Error fetching object ${key} from bucket ${bucket}:`, error);    throw error;  }}function verifyImageType(contentType, dstKey) {  if (!isImage(contentType)) {    throw new Error(`not support contentType = ${contentType} / dstKey = ${dstKey}`);  }}async function processAndUploadImages({  dstBucket,  dstKey,  response}) {  const contentType = response.ContentType;  const contentBuffer = Buffer.concat(await response.Body.toArray());  verifyImageType(contentType, dstKey);  for (const width of widths) {    let processedImageBuffer;    // HEIC 이미지의 경우 변환 처리    if (contentType === 'image/heic') {      console.log(\"heic file\")      const convertedBuffer  = await convertHeicToJpeg(contentBuffer);      processedImageBuffer = await resizeImage(convertedBuffer, width, contentType);    }else{      processedImageBuffer = await resizeImage(contentBuffer, width, contentType);    }    await uploadResizedImage(dstBucket, `${width}/${dstKey}`, processedImageBuffer);  }}// HEIC 이미지를 JPEG로 변환async function convertHeicToJpeg(buffer) {  try {    return await convert({      buffer: buffer, // HEIC 파일의 Buffer      format: 'JPEG', // HEIC to JPEG      quality: 1 // 품질 설정 (0 ~ 1)    });  } catch (error) {    console.error('Error converting HEIC to JPEG:', error);    throw error;  }}// Resize imageasync function resizeImage(buffer, width) {  try {    return sharp(buffer)    .resize(width, null, {fit: 'contain'}) // height 는 width 에 자동적으로 맞춰짐    .jpeg({quality: 80}) // 퀄리티 ( 0 ~ 100 )    .withMetadata() // 원본 metadata 그대로 가지도록 함    .toBuffer();  } catch (error) {    console.error('Error resizing image:', error);    throw error;  }}// Upload resized image to S3async function uploadResizedImage(bucket, key, buffer) {  const params = {    Bucket: bucket,    Key: key,    Body: buffer,    ContentType: 'image/jpeg',  };  try {    await s3.send(new PutObjectCommand(params));    console.log(`Successfully uploaded ${key} to ${bucket}`);  } catch (error) {    console.error(`Error uploading ${key} to ${bucket}:`, error);    throw error;  }}function isImage( contentType) {  return contentType.startsWith(\"image/\");}// Lambda handler functionexport const handler = async (event) =&gt; {  console.log(\"이벤트 처리 중 ... :\", util.inspect(event, {depth: 5}));  const {srcBucket, srcKey, dstBucket, dstKey} = parseBucketInfoFromEvent(event);  const response = await fetchObject({bucket: srcBucket, key: srcKey});  await processAndUploadImages({dstBucket, dstKey, response});};의존이 필요한 패키지들은 npm build 를 통해 설치한 후 zip 파일로 압축하여 업로드 한다.코드를 간단하게 설명하면  parseBucketInfoFromEvent(event) : 수신괸 S3 Events 로 부터 필요한 정보를 파싱(키, 버킷이름)  fetchObject(bucket, key): 버킷이름와 키를 이용하여 S3에 방급 저장된 이미지를 조회  processAndUploadImages(dstBucket, dstKey, response) : 가져온 이미지를 크기별(80, 500)로 리사이징 한 후 S3에 업로드sharp 는 이미지 포맷 변환을 지원한다.하지만 HEIC 포멧의 이미지파일인 경우 Nokia의 HEIF 라이브러리 라이센스로 인해 Sharp를 사용하려면 libheif, libde265 및 x265를 지원하도록 컴파일된 전역 설치 libvips를 사용해야 한다고 한다. 관련해서 해결한 블로그도 존재하지만, 나는 별도로 HEIC 를 JPG 로 바꾸는 라이브러리를 추가하여 해결했다.조회한 이미지의 response.ContentType 의 경우가 “image/heic” 인 경우에는 jpg 로 변환 후 이미지 리사이징 작업을 하도록 했다.업로드 용 PresignedURI 생성 코드또 다른 람다함수를 만들고 아래의 코드를 추가한다. 만들 때 역할은 위에서 만든 역할 그대로 사용하였다.import { PutObjectCommand, S3Client } from \"@aws-sdk/client-s3\";import { getSignedUrl, S3RequestPresigner } from \"@aws-sdk/s3-request-presigner\";import { randomUUID } from 'crypto';const REGION = \"리전\";const BUCKET = \"버킷이름\";const createPresignedUrlWithClient = ({ region, bucket, key }) =&gt; {  const client = new S3Client({ region });  const command = new PutObjectCommand({ Bucket: bucket, Key: key });  return getSignedUrl(client, command, { expiresIn: 360000 });};export const handler = async (event, context, callback) =&gt; {        const clientUrl = await createPresignedUrlWithClient({      region: REGION,      bucket: BUCKET,      key: randomUUID(),  \t});        return {      result: \"SUCCESS\",      data: [ clientUrl ]  \t}  }};업로드용 PresignedURI 의 경우, 방안4 에 나온 구조에서 보듯이 API Gateway 로 요청이 온 후 연결된 Lambda 함수에서 응답해야 하기 때문에 생성된 presignedUri 를 리턴하고 있다.API Gateway이제 PresignedURI 만드는 람다함수를 API 로 노출시키기 위해 먼저 API Gateway를 만들어야 한다.API Gateway 생성HTTP API 선택이때 API Gateway가 Lambda 함수를 호출해야하기 때문에, 아까 만든 Lambda 함수를 지정한다.다음버튼을 눌러 계속 진행한다.여기서 API Gateway의 메서드와 경로를 구성할 수 있다. 물론 만들고 나서 수정해도 상관없다. 나는 “GET /image/presigned-uri” 으로 경로를 설정했다.마지막으로 스테이지까를 정의한다. 이는 말그대로 스테이지 환경을 정의할 수 있으며 API 스테이지는 API ID 및 스테이지 이름으로 식별되며, API를 호출하는 데 사용되는 URL에 포함됩니다.HTTP URI에 스테이지 변수를 사용하여 구성하는 자세한 사용법은 https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/http-api-stages.html 에 있으니 참고바란다.새롭게 생성한 API를 볼 수 있다. 좀 전에 dev 라는 이름의 스테이지 이름을 사용하는 스테이지의 경우에는 현재 자동배포되지 않기 때문에 만약 dev 스테이지에도 배포를 원한다면 우측 상단에 있는 배포 버튼을 클릭하여 배포를 진행하면 된다.이제 아래의 경로로 API 호출을 하면https://{app_id}.execute-api.ap-northeast-2.amazonaws.com/image/presigned-uriPresigned URI 를 받는 것을 알 수 있다.번외, API Gateway 사용자 지정 도메인 설정하기AWS 에서 제공하는 URI 주소 말고 사용자 지정 도메인 이름을 지정할 수 있다.현재 itthatcat.xyz 도메인을 가비아 네임서버에 등록해놓은 상태이고 와일드 카드 인증서를 LetsEncrypted 를 통해 무료로 발급한 상태이다.이제 img.itthatcat.xyz 의 새로운 서브도메인을 설정해보자.https://{app_id}.execute-api.ap-northeast-2.amazonaws.com/image/presigned-uri 로 호출하는 것이 아닌https://img.itthatcat.xyz/image/presigned-uri 로 호출할 수 있도록 하자도메인 이름에는 사용하고자 하는 도메인 이름을 입력한다. (당연히 사용하고자 하는 도메인에 대해서 구입이 완료되어야 한다.)그리고 해당 도메인에 대해 발급한 인증서가 필요하다.사용하려고 하는 도메인에 ACM SSL 인증서 발급받기 with AWS가 아닌 다른 네임서버 사용중인증서의 경우 이미 만든 인증서를 가져와서 사용해도 좋지만, 나는 해당 도메인에 대해서는 새롭게 SSL 인증서를 만들기로 했다. 인증서가 여러개로 분산되어 관리의 포인트가 늘어난 다는 단점이 있지만, AWS ACM에서 만든 인증서의 경우 인증서의 갱신을 자동화할 수 있고 무료이다. 물론 원한다면 외부에서 사용된 인증서를 가져와서 사용할 수 있다. 다만 외부의 인증서의 경우 만료되었을 경우 갱신에 대한 로직은 대신해주지 않는다.이제 네임 서버에 CNAME 레코드를 만들면 된다. 이를 통해 DNS 검증을 받는 것이다.이때 CNAME 레코드 등록시 호스트에는 _21jkddfu2j.img.itthatcat.xyz. 에서 호스트 이름인 _21jkddfu2j.img 까지만 입력해야한다. 그 외는 그대로 입력한다.만약 서브도메인이 아닌경우라면_21jkddfu2j.itthatcat.xyz. 요렇게 될것이다. 그리고 CNAME 레코드 호스트는 _21jkddfu2j 입력하면 된다.어느 정도 시간이 지나면 이렇게 “검증 대기중”에서 “발급” 상태로 바뀐 것을 알 수있다.(CNAME 레코드를 추가하고 10분 내로 발급되었다)사용자지정 도메인 등록하기사용하려고 하는 도메인 이름과 발급받은 ACM 인증서를 등록합니다.사용자 지정 도메인와 API Gateway 매핑하기이렇게 사용자 지정 도메인에 대해 새로운 API Gateway 도메인 이름이 생겼다.이제 다시 가비아로 돌아와서 DNS 레코드를 추가해야한다. CNAME 레코드를 추가하여 img.itthatcat.xyz 로 접속했을 때 위의 가려진 도메인으로 이동할 수 있도록 해야한다.매핑하려고 하는 API 를 선택한다.이제 https://img.itthatcat.xyz/image/presigned-uri 로 요청해보자.정상적으로 데이터가 잘 나오는 것을 알 수 있다.번외현재는 API Gateway 앞단에 Cloudfront 를 구성한 후 Cloudfront -&gt; API Gateway -&gt; Lambda 로 호출하도록 구성한 상태이다.Cloudfront 역시 API Gateway 와 마찬가지로 AWS 에서 제공하는 도메인 이름이 아닌 새롭게 커스텀 도메인을 사용할 수 있으며 SSL 인증서 적용하는 방식도 같다.참고https://obviy.us/blog/sharp-heic-on-aws-lambda/https://docs.aws.amazon.com/ko_kr/acm/latest/userguide/troubleshooting-DNS-validation.html",
            "content_html": "<h1 id=\"20240221---aws-lambda-를-활용한-이미지-리사이징-적용기\">2024.02.21 - AWS Lambda 를 활용한 이미지 리사이징 적용기</h1><h3 id=\"들어가면서\">들어가면서</h3><p>현재 진행하고 있는 프로젝트에는 이미지 업로드 기능이 있다. 클라이언트가 API 키를 이용하여 Cloudnary 에 이미지를 업로드 한 후 업로드 된 이미지 URI와 포스팅하려고 하는 내용과 함께 서버에 등록하는 방식이다. 하지만 이러한 방식은 다소 문제가 일어날 요지가 있어 이미지 업로드 과정을 개선해보았다.</p><h3 id=\"문제\">문제</h3><p>클라이언트 (프론트엔드) 가 미리 정의된 API 키를 이용하여 이미지서버 (<strong>Cloudnary</strong>) 에 이미지를 바로 저장하고 있다. 즉, 클라이언트가 이미지 저장에 대한 모든 권한을 가지고 있는 셈이다. 이때 API 키는 클라이언트에 노출되어있기때문에 KEY가 탈취된다면 언제든지 누군가 사용해서 이미지를 업로드 할 수 있는 문제가 생긴다.또한 현재 프로젝트에서 사용되는 이미지 사이즈는 최대 500px 임에도 불구하고 클라이언트로 부터 원본 이미지를 저장한 후 저장된 원본이미지를 그대로 사용하고 있다. 원본 사이즈 크기를 사용할 필요가 없음에도 불구하고 불필요하게 이미지 다운로드 용량을 낭비하고 있다.</p><ol>  <li>보안적인 문제로 인해 클라이언트가 아닌 서버에서 이미지 저장을 처리해야 한다.</li>  <li>불필요한 네트워크 낭비를 방지하고자 요청할 때는 리사이징된 작은 사이즈의 이미지를 요청할 수 있도록 한다.</li></ol><h3 id=\"해결\">해결</h3><ol>  <li>    <p>S3 이미지 저장에 대한 권한은 일시간동안만 사용가능한 업로드 용 Presigned URI 를 만들어 해당 URI를 통해 클라이언트가 이미지를 업로드 할 수 있게 하여 클라이언트가 업로드에 대한 모든 권한을 가질 수 없도록 하였다.</p>  </li>  <li>    <p>API 서버에서 하지 않아도 외부에서 리사이징 작업을 할 수 있기 위해서 S3 와 Lambda 를 이용하여 이미지 리사이징에 대한 처리를 하였다.</p>  </li></ol><p>위와 같은 해결은 쉽게 나오진 않았다. 아래의 상황을 고려한 후 최종적으로 S3 와 Lambda, API Gateway 를 이용한 이미지 처리방식을 채택하였다.</p><h3 id=\"방안-1\">방안 1</h3><p>먼저 처음 생각한 이미지 처리 방식이다.<img src=\"https://velog.velcdn.com/images/kmss6905/post/39d255a6-d037-4aa2-840b-440147e60296/image.png\" alt=\"\" /></p><p>직관적으로 생각한 방식이다.클라이언트가 이미지(최대 3개까지) multipart 방식으로 API 서버로 이미지를 업로드 하면, 서버는 S3에 권한을 가진 IAM 사용자의 AccessKey 와 SecretKey 를 이용하여 S3에 이미지를 저장한다.저장 후에는 저장된 S3 이미지 URI를 저장하려고 하는 컨텐츠 정보와 함께 데이터베이스에 저장한다.</p><p>이 과정이 모두 완료되면 클라이언트에 성공 응답(200)을 한다.</p><p>이렇게 한다면 이미지 저장에 대한 권한은 서버에 있기 때문에 1번에 대한 문제가 해결된다.또한 이미지 리사이징도 서버에서 하기 때문에 이 또한 문제가 될 상황은 없어 보인다.</p><p>하지만 클라이언트의 이미지 요청 이후 2, 3, 4번 의 응답이 늦어지면 늦어질 수록 최종 클라이언트로 가는 응답 역시 늦어질 수 밖에 없다.</p><p>그래서 이미지 리사이징 처리를 다른 곳에서 할 수 있는 방안을 생각해보았다.</p><p>(2번과 3번의 과정을 비동기 요청으로 할 경우 위와 같은 문제를 해결할 수 있을 것 같다. 하지만 비동기는 아직 익숙치 않기 때문에 그보다는 다른 방법으로 해결하기로 했다. 추후에 시간이 된다면 비동기에 대한 부분도 다루어 보도록 하겠다)</p><h3 id=\"방안-2\">방안 2</h3><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/4890d484-47ca-491d-9aba-fc86dba254e8/image.png\" alt=\"\" /></p><p>방안 1에 비해서는 구조가 복잡해 보인다. S3 이외에 Lambda 가 추가되었다.크게 두 가지의 FLOW가 존재한다.</p><h4 id=\"flow-1\">FLOW 1</h4><ol>  <li>클라이언트가 API서버로 이미지를 전송한다.</li>  <li>API 서버는 클라이언트로 부터 받은 이미지를 S3에 업로드 한다.</li>  <li>S3에 저장된 이미지 URI를 요청받는 컨텐츠와 함께 DB에 저장한다.</li>  <li>저장이 완료되면 클라이언트로 성공 응답(200) 을 보낸다.</li></ol><h4 id=\"flow-2\">FLOW 2</h4><ol>  <li>S3에 이미지가 저장될 경우 이미지 리사이징을 담당하는 Lambda 함수로 Events를 보낸다.</li>  <li>Lambda 함수는 저장된 S3 이미지를 가져와 리사이징 작업을 한다.</li>  <li>리사이징 작업이 끝나면 크기별로 S3에 저장한다.</li></ol><p>참고로 FLOW 1 번과 FLOW 2은 별개로 진행된다.</p><p>그리고 서버는 더 이상 이미지 리사이징 작업을 하지 않아도 된다. 최소한 리사이징 작업으로 인해 응답이 지연되지는 않는다. 하지만 S3에 이미지를 저장하는 건 여전히 API 서버가 담당하고 있다.</p><h3 id=\"방안-3\">방안 3</h3><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/f114ee16-fdfc-4beb-96ec-812756743cde/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/72766403-160f-42e5-aa86-53d738928f1e/image.png\" alt=\"\" /></p><p>방안 2보다 훨씬 복잡해졌다.</p><p>방안2와 다른 점은 이미지저장을 더 이상 서버에서 하지 않는다. 대신 서버에서는 이미지를 저장할 수 있는 Presigned URI 를 생성하도록 S3에 요청한다.</p><p>클라이언트는 이 Presigned URI를 이용해 서버가 아닌 바로 S3에 이미지를 업로드한다. 이후 S3에 업로드 되어 진행되는 리사이징 과정은 Lambda 를 통해 이루어진다. (방안 2와 같다)</p><p>이후에는 Presigned URI 와 함께 추가 저장할 컨텐츠 정보를 서버로 전달합니다. 서버는 이미지 URI 를 저장한 후 클라이언트로 성공응답(200)을 보낸다.</p><p>Presigned URI 의 경우 20분의 유효시간을 정했다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nf\">AWSPresignedUriService</span><span class=\"o\">(){</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">AmazonS3</span> <span class=\"n\">s3</span><span class=\"o\">;</span>        <span class=\"kd\">public</span> <span class=\"nf\">AWSPresignedUriService</span><span class=\"o\">(</span><span class=\"kd\">final</span> <span class=\"nc\">AmazonS3</span> <span class=\"n\">s3</span><span class=\"o\">){</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">s3</span> <span class=\"o\">=</span> <span class=\"n\">s3</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    \t<span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">generatePresignedUri</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">bucketName</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">filePath</span><span class=\"o\">){</span>\t\t<span class=\"nc\">Calendar</span> <span class=\"n\">calendar</span> <span class=\"o\">=</span> <span class=\"nc\">Calendar</span><span class=\"o\">.</span><span class=\"na\">getInstance</span><span class=\"o\">();</span>        <span class=\"n\">calendar</span><span class=\"o\">.</span><span class=\"na\">setTime</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">Date</span><span class=\"o\">());</span>        <span class=\"n\">calendar</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"nc\">Calendar</span><span class=\"o\">.</span><span class=\"na\">MINUTE</span><span class=\"o\">,</span> <span class=\"mi\">20</span><span class=\"o\">);</span> <span class=\"c1\">// 20분의 유효시간</span>        <span class=\"k\">return</span> <span class=\"n\">s3</span><span class=\"o\">.</span><span class=\"na\">generatePresigenedUri</span><span class=\"o\">(</span><span class=\"n\">bucketName</span><span class=\"o\">,</span> <span class=\"n\">filePath</span><span class=\"o\">,</span> <span class=\"n\">calendar</span><span class=\"o\">.</span><span class=\"na\">getTime</span><span class=\"o\">(),</span> <span class=\"nc\">HttpMethod</span><span class=\"o\">.</span><span class=\"na\">PUT</span><span class=\"o\">).</span><span class=\"na\">toString</span><span class=\"o\">();</span>\t<span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>20분의 유효시간이 끝나면 발급받은 Presigned URI 는 더 이상 사용할 수 없다.이제 서버가 이미지와 관련된 작업을 하는 건 S3에 Presigned URI 를 생성하기 위해 요청하는 작업만 있다.</p><p>하지만 아직까지 이미지 처리와 관련해서 서버에서 프로그래밍 방식으로 Presigned URI를 생성하기 때문에 버킷 이름이나 파일 경로를 바꾸기 위해서는 서버 코드를 수정해야하는 단점이 존재한다.</p><p>이미지와 관련된 작업은 사실 크게 비지니스 로직에 벗어나지 않음에도 불구하고 새로운 Presigend URI를 만들기 위해 API 서버 코드를 수정하여 배포하고 싶지는 않았다.</p><h3 id=\"방안-4\">방안 4</h3><p>이미지 리사이징 Lambda 와 더불어 Presigned URI 를 생성하는 Lambda 를 추가한 후 API Gateway 를 만들어 Lambda 함수를 API 형태로 노출시킨다.</p><p>이로써 더 이상 API 서버에서는 이미지와 관련된 작업을 더 이상 하지 않게 되었다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/d07a2405-4b82-4eea-b1d5-06c661dedea4/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/04bf8d8e-f9df-447c-9c82-cad7290956e8/image.png\" alt=\"\" /></p><p>또한 API Gateway 는 “수신한 API 호출 1백만 건 무료” 이기 때문에 우리 프로젝트에 사용하기에는 충분했다.</p><p>만약 새로운 Bucket 에 대해서 Presigned URI 을 생성하고 싶다면 서버코드는 전혀 건들이지 않고 Lambda 함수만 수정하면 되는 장점이 생겼다. 이제 더 이상 이미지와 관련된 작업은 API 서버에서 생각하지 않아도 되었다.</p><h2 id=\"개발과정\">개발과정</h2><h3 id=\"s3와-cloudwatch-의-권한을-가진-새로운-정책-생성하기\">S3와 CloudWatch 의 권한을 가진 새로운 정책 생성하기</h3><p>리사이징을 담당하는 람다 함수와 이미지 업로드 가능하도록 하는 Presigned URI 를 만들기 위해서는 S3에 권한이 있어야한다.</p><p>이미지 리사이징을 담당하는 람다 함수의 경우 S3 로 부터 Event 를 받아 S3 이미지를 조회한 후 이미지 사이즈 별로 S3에 업로드 해야하기 때문에 S3 GET, PUT 에 대해 허용권한이 있어야한다.</p><p>IAM &gt; 정책 &gt; 정책 생성 으로 들어가 필요한 권한을 설정해준다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/6df34801-e732-4850-80fc-993ea89c03bc/image.png\" alt=\"\" /></p><p>참고로 Cloudwatch 에서 람다 이벤트에 대한 로그가 수집될 수 있도록 필요한 권한 역시 설정한다.</p><p>정책을 생성했으니 이제 Role(역할)을 생성해야한다. Lambda 와 같은 AWS 리소스에 일시적으로 권한을 부여할 수 있는 데 Role 을 부여함으로써 가능하다. 또한 Role은 Policy와 연결되어야 사용할 수 있기 때문에 필요한 Lambda 가 사용할 역할을 만든다.</p><p>역할은 IAM &gt; 역할 &gt; 역할 생성 에 들어가서 만들면 된다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/2e27fe29-17f8-4a57-9448-3c9b6dac53bd/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/91a23969-31e8-48a3-81a5-137622cb3931/image.png\" alt=\"\" /></p><p>권한 추가 항목에서는 아까 만든 정책(위의 스샷에서는 안보이지만 정책이름을 LambdaS3Policy 로 하였다) 선택한다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/df398e10-c78a-4e84-8248-cfa4197b787a/image.png\" alt=\"\" />역할 이름을 넣고 역할생성 버튼을 눌러 역할을 생성한다.</p><h3 id=\"lambda-함수-생성하기\">Lambda 함수 생성하기</h3><p>Lambda &gt; 함수 &gt; 함수 생성에 들어가 Lambda 함수를 생성한다.<img src=\"https://velog.velcdn.com/images/kmss6905/post/f6fb8db0-6930-4df5-847b-3d026d1d1ea5/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/b36c9288-c795-42af-a8bf-32021ca5863d/image.png\" alt=\"\" /></p><p>이때 Lambda 생성시 실행역할을 아까 만들었던 LambdaS3Role 로 선택한다. (먼저 Lambda 를 만들고 추구 Lambda &gt; 구성 &gt; 권한 &gt; 편집 항목에서 원하는 역할로 바꿀 수 있기 때문에 무엇을 먼저 만들지는 상관없다.)</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/794873a8-723d-4e95-8c91-fa5b0e05357b/image.png\" alt=\"\" /><img src=\"https://velog.velcdn.com/images/kmss6905/post/6836952d-53e1-44fd-864e-c097c8877c9c/image.png\" alt=\"\" /></p><h4 id=\"이미지-리사이징-코드\">이미지 리사이징 코드</h4><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"k\">import</span> <span class=\"p\">{</span><span class=\"nx\">S3Client</span><span class=\"p\">,</span> <span class=\"nx\">GetObjectCommand</span><span class=\"p\">,</span> <span class=\"nx\">PutObjectCommand</span><span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">@aws-sdk/client-s3</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span><span class=\"nx\">Readable</span><span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">stream</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"nx\">sharp</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">sharp</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"nx\">util</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">util</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"nx\">convert</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">heic-convert</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">s3</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">S3Client</span><span class=\"p\">({</span><span class=\"na\">region</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">ap-northeast-2</span><span class=\"dl\">'</span><span class=\"p\">});</span><span class=\"kd\">const</span> <span class=\"nx\">widths</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">80</span><span class=\"p\">,</span> <span class=\"mi\">500</span><span class=\"p\">];</span><span class=\"kd\">function</span> <span class=\"nf\">parseBucketInfoFromEvent</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"s2\">`Event: </span><span class=\"p\">${</span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nf\">stringify</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">)}</span><span class=\"s2\">`</span><span class=\"p\">);</span>  <span class=\"kd\">const</span> <span class=\"nx\">record</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">Records</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">s3</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">srcBucket</span> <span class=\"o\">=</span> <span class=\"nx\">record</span><span class=\"p\">.</span><span class=\"nx\">bucket</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">srcKey</span> <span class=\"o\">=</span> <span class=\"nf\">decodeURIComponent</span><span class=\"p\">(</span><span class=\"nx\">record</span><span class=\"p\">.</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">key</span><span class=\"p\">.</span><span class=\"nf\">replace</span><span class=\"p\">(</span><span class=\"sr\">/</span><span class=\"se\">\\+</span><span class=\"sr\">/g</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\"> </span><span class=\"dl\">\"</span><span class=\"p\">));</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"nx\">srcBucket</span><span class=\"p\">,</span>    <span class=\"nx\">srcKey</span><span class=\"p\">,</span>    <span class=\"na\">dstBucket</span><span class=\"p\">:</span> <span class=\"s2\">`</span><span class=\"p\">${</span><span class=\"nx\">srcBucket</span><span class=\"p\">}</span><span class=\"s2\">-resized`</span><span class=\"p\">,</span>    <span class=\"na\">dstKey</span><span class=\"p\">:</span> <span class=\"s2\">`</span><span class=\"p\">${</span><span class=\"nx\">srcKey</span><span class=\"p\">}</span><span class=\"s2\">.jpg`</span><span class=\"p\">,</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"c1\">// Fetch object from S3</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nf\">fetchObject</span><span class=\"p\">({</span><span class=\"nx\">bucket</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">})</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">params</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"na\">Bucket</span><span class=\"p\">:</span> <span class=\"nx\">bucket</span><span class=\"p\">,</span> <span class=\"na\">Key</span><span class=\"p\">:</span> <span class=\"nx\">key</span><span class=\"p\">};</span>  <span class=\"k\">try</span> <span class=\"p\">{</span>    <span class=\"kd\">const</span> <span class=\"nx\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">s3</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nc\">GetObjectCommand</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">));</span>    <span class=\"kd\">const</span> <span class=\"nx\">contentType</span> <span class=\"o\">=</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">ContentType</span><span class=\"p\">;</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"s2\">`ContentType: </span><span class=\"p\">${</span><span class=\"nx\">contentType</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">);</span>    <span class=\"k\">if </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">Body</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Readable</span><span class=\"p\">))</span> <span class=\"p\">{</span>      <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nc\">Error</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Expected a stream in the response body</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"p\">}</span>    <span class=\"k\">return</span> <span class=\"nx\">response</span><span class=\"p\">;</span>  <span class=\"p\">}</span> <span class=\"k\">catch </span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"s2\">`Error fetching object </span><span class=\"p\">${</span><span class=\"nx\">key</span><span class=\"p\">}</span><span class=\"s2\"> from bucket </span><span class=\"p\">${</span><span class=\"nx\">bucket</span><span class=\"p\">}</span><span class=\"s2\">:`</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">);</span>    <span class=\"k\">throw</span> <span class=\"nx\">error</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nf\">verifyImageType</span><span class=\"p\">(</span><span class=\"nx\">contentType</span><span class=\"p\">,</span> <span class=\"nx\">dstKey</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">if </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nf\">isImage</span><span class=\"p\">(</span><span class=\"nx\">contentType</span><span class=\"p\">))</span> <span class=\"p\">{</span>    <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nc\">Error</span><span class=\"p\">(</span><span class=\"s2\">`not support contentType = </span><span class=\"p\">${</span><span class=\"nx\">contentType</span><span class=\"p\">}</span><span class=\"s2\"> / dstKey = </span><span class=\"p\">${</span><span class=\"nx\">dstKey</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">);</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nf\">processAndUploadImages</span><span class=\"p\">({</span>  <span class=\"nx\">dstBucket</span><span class=\"p\">,</span>  <span class=\"nx\">dstKey</span><span class=\"p\">,</span>  <span class=\"nx\">response</span><span class=\"p\">})</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">contentType</span> <span class=\"o\">=</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">ContentType</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">contentBuffer</span> <span class=\"o\">=</span> <span class=\"nx\">Buffer</span><span class=\"p\">.</span><span class=\"nf\">concat</span><span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">Body</span><span class=\"p\">.</span><span class=\"nf\">toArray</span><span class=\"p\">());</span>  <span class=\"nf\">verifyImageType</span><span class=\"p\">(</span><span class=\"nx\">contentType</span><span class=\"p\">,</span> <span class=\"nx\">dstKey</span><span class=\"p\">);</span>  <span class=\"k\">for </span><span class=\"p\">(</span><span class=\"kd\">const</span> <span class=\"nx\">width</span> <span class=\"k\">of</span> <span class=\"nx\">widths</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"kd\">let</span> <span class=\"nx\">processedImageBuffer</span><span class=\"p\">;</span>    <span class=\"c1\">// HEIC 이미지의 경우 변환 처리</span>    <span class=\"k\">if </span><span class=\"p\">(</span><span class=\"nx\">contentType</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">image/heic</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">heic file</span><span class=\"dl\">\"</span><span class=\"p\">)</span>      <span class=\"kd\">const</span> <span class=\"nx\">convertedBuffer</span>  <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nf\">convertHeicToJpeg</span><span class=\"p\">(</span><span class=\"nx\">contentBuffer</span><span class=\"p\">);</span>      <span class=\"nx\">processedImageBuffer</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nf\">resizeImage</span><span class=\"p\">(</span><span class=\"nx\">convertedBuffer</span><span class=\"p\">,</span> <span class=\"nx\">width</span><span class=\"p\">,</span> <span class=\"nx\">contentType</span><span class=\"p\">);</span>    <span class=\"p\">}</span><span class=\"k\">else</span><span class=\"p\">{</span>      <span class=\"nx\">processedImageBuffer</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nf\">resizeImage</span><span class=\"p\">(</span><span class=\"nx\">contentBuffer</span><span class=\"p\">,</span> <span class=\"nx\">width</span><span class=\"p\">,</span> <span class=\"nx\">contentType</span><span class=\"p\">);</span>    <span class=\"p\">}</span>    <span class=\"k\">await</span> <span class=\"nf\">uploadResizedImage</span><span class=\"p\">(</span><span class=\"nx\">dstBucket</span><span class=\"p\">,</span> <span class=\"s2\">`</span><span class=\"p\">${</span><span class=\"nx\">width</span><span class=\"p\">}</span><span class=\"s2\">/</span><span class=\"p\">${</span><span class=\"nx\">dstKey</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">,</span> <span class=\"nx\">processedImageBuffer</span><span class=\"p\">);</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// HEIC 이미지를 JPEG로 변환</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nf\">convertHeicToJpeg</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">try</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"k\">await</span> <span class=\"nf\">convert</span><span class=\"p\">({</span>      <span class=\"na\">buffer</span><span class=\"p\">:</span> <span class=\"nx\">buffer</span><span class=\"p\">,</span> <span class=\"c1\">// HEIC 파일의 Buffer</span>      <span class=\"na\">format</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">JPEG</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"c1\">// HEIC to JPEG</span>      <span class=\"na\">quality</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"c1\">// 품질 설정 (0 ~ 1)</span>    <span class=\"p\">});</span>  <span class=\"p\">}</span> <span class=\"k\">catch </span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Error converting HEIC to JPEG:</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">);</span>    <span class=\"k\">throw</span> <span class=\"nx\">error</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// Resize image</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nf\">resizeImage</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">,</span> <span class=\"nx\">width</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">try</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"nf\">sharp</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">)</span>    <span class=\"p\">.</span><span class=\"nf\">resize</span><span class=\"p\">(</span><span class=\"nx\">width</span><span class=\"p\">,</span> <span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"na\">fit</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">contain</span><span class=\"dl\">'</span><span class=\"p\">})</span> <span class=\"c1\">// height 는 width 에 자동적으로 맞춰짐</span>    <span class=\"p\">.</span><span class=\"nf\">jpeg</span><span class=\"p\">({</span><span class=\"na\">quality</span><span class=\"p\">:</span> <span class=\"mi\">80</span><span class=\"p\">})</span> <span class=\"c1\">// 퀄리티 ( 0 ~ 100 )</span>    <span class=\"p\">.</span><span class=\"nf\">withMetadata</span><span class=\"p\">()</span> <span class=\"c1\">// 원본 metadata 그대로 가지도록 함</span>    <span class=\"p\">.</span><span class=\"nf\">toBuffer</span><span class=\"p\">();</span>  <span class=\"p\">}</span> <span class=\"k\">catch </span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Error resizing image:</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">);</span>    <span class=\"k\">throw</span> <span class=\"nx\">error</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// Upload resized image to S3</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nf\">uploadResizedImage</span><span class=\"p\">(</span><span class=\"nx\">bucket</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">buffer</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">params</span> <span class=\"o\">=</span> <span class=\"p\">{</span>    <span class=\"na\">Bucket</span><span class=\"p\">:</span> <span class=\"nx\">bucket</span><span class=\"p\">,</span>    <span class=\"na\">Key</span><span class=\"p\">:</span> <span class=\"nx\">key</span><span class=\"p\">,</span>    <span class=\"na\">Body</span><span class=\"p\">:</span> <span class=\"nx\">buffer</span><span class=\"p\">,</span>    <span class=\"na\">ContentType</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">image/jpeg</span><span class=\"dl\">'</span><span class=\"p\">,</span>  <span class=\"p\">};</span>  <span class=\"k\">try</span> <span class=\"p\">{</span>    <span class=\"k\">await</span> <span class=\"nx\">s3</span><span class=\"p\">.</span><span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nc\">PutObjectCommand</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">));</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"s2\">`Successfully uploaded </span><span class=\"p\">${</span><span class=\"nx\">key</span><span class=\"p\">}</span><span class=\"s2\"> to </span><span class=\"p\">${</span><span class=\"nx\">bucket</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">);</span>  <span class=\"p\">}</span> <span class=\"k\">catch </span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"s2\">`Error uploading </span><span class=\"p\">${</span><span class=\"nx\">key</span><span class=\"p\">}</span><span class=\"s2\"> to </span><span class=\"p\">${</span><span class=\"nx\">bucket</span><span class=\"p\">}</span><span class=\"s2\">:`</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">);</span>    <span class=\"k\">throw</span> <span class=\"nx\">error</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nf\">isImage</span><span class=\"p\">(</span> <span class=\"nx\">contentType</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"nx\">contentType</span><span class=\"p\">.</span><span class=\"nf\">startsWith</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">image/</span><span class=\"dl\">\"</span><span class=\"p\">);</span><span class=\"p\">}</span><span class=\"c1\">// Lambda handler function</span><span class=\"k\">export</span> <span class=\"kd\">const</span> <span class=\"nx\">handler</span> <span class=\"o\">=</span> <span class=\"k\">async </span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">이벤트 처리 중 ... :</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"nx\">util</span><span class=\"p\">.</span><span class=\"nf\">inspect</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"na\">depth</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">}));</span>  <span class=\"kd\">const</span> <span class=\"p\">{</span><span class=\"nx\">srcBucket</span><span class=\"p\">,</span> <span class=\"nx\">srcKey</span><span class=\"p\">,</span> <span class=\"nx\">dstBucket</span><span class=\"p\">,</span> <span class=\"nx\">dstKey</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nf\">parseBucketInfoFromEvent</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">);</span>  <span class=\"kd\">const</span> <span class=\"nx\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nf\">fetchObject</span><span class=\"p\">({</span><span class=\"na\">bucket</span><span class=\"p\">:</span> <span class=\"nx\">srcBucket</span><span class=\"p\">,</span> <span class=\"na\">key</span><span class=\"p\">:</span> <span class=\"nx\">srcKey</span><span class=\"p\">});</span>  <span class=\"k\">await</span> <span class=\"nf\">processAndUploadImages</span><span class=\"p\">({</span><span class=\"nx\">dstBucket</span><span class=\"p\">,</span> <span class=\"nx\">dstKey</span><span class=\"p\">,</span> <span class=\"nx\">response</span><span class=\"p\">});</span><span class=\"p\">};</span></code></pre></div></div><p>의존이 필요한 패키지들은 npm build 를 통해 설치한 후 zip 파일로 압축하여 업로드 한다.</p><p>코드를 간단하게 설명하면</p><ol>  <li>parseBucketInfoFromEvent(event) : 수신괸 S3 Events 로 부터 필요한 정보를 파싱(키, 버킷이름)</li>  <li>fetchObject(bucket, key): 버킷이름와 키를 이용하여 S3에 방급 저장된 이미지를 조회</li>  <li>processAndUploadImages(dstBucket, dstKey, response) : 가져온 이미지를 크기별(80, 500)로 리사이징 한 후 S3에 업로드</li></ol><p>sharp 는 이미지 포맷 변환을 지원한다.</p><p>하지만 HEIC 포멧의 이미지파일인 경우 Nokia의 HEIF 라이브러리 라이센스로 인해 Sharp를 사용하려면 libheif, libde265 및 x265를 지원하도록 컴파일된 전역 설치 libvips를 사용해야 한다고 한다. 관련해서 해결한 <a href=\"https://obviy.us/blog/sharp-heic-on-aws-lambda/\">블로그</a>도 존재하지만, 나는 별도로 HEIC 를 JPG 로 바꾸는 라이브러리를 추가하여 해결했다.</p><p>조회한 이미지의 response.ContentType 의 경우가 “image/heic” 인 경우에는 jpg 로 변환 후 이미지 리사이징 작업을 하도록 했다.</p><h4 id=\"업로드-용-presigneduri-생성-코드\">업로드 용 PresignedURI 생성 코드</h4><p>또 다른 람다함수를 만들고 아래의 코드를 추가한다. 만들 때 역할은 위에서 만든 역할 그대로 사용하였다.</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">PutObjectCommand</span><span class=\"p\">,</span> <span class=\"nx\">S3Client</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">\"</span><span class=\"s2\">@aws-sdk/client-s3</span><span class=\"dl\">\"</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">getSignedUrl</span><span class=\"p\">,</span> <span class=\"nx\">S3RequestPresigner</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">\"</span><span class=\"s2\">@aws-sdk/s3-request-presigner</span><span class=\"dl\">\"</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">randomUUID</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">crypto</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">REGION</span> <span class=\"o\">=</span> <span class=\"dl\">\"</span><span class=\"s2\">리전</span><span class=\"dl\">\"</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">BUCKET</span> <span class=\"o\">=</span> <span class=\"dl\">\"</span><span class=\"s2\">버킷이름</span><span class=\"dl\">\"</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">createPresignedUrlWithClient</span> <span class=\"o\">=</span> <span class=\"p\">({</span> <span class=\"nx\">region</span><span class=\"p\">,</span> <span class=\"nx\">bucket</span><span class=\"p\">,</span> <span class=\"nx\">key</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">client</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">S3Client</span><span class=\"p\">({</span> <span class=\"nx\">region</span> <span class=\"p\">});</span>  <span class=\"kd\">const</span> <span class=\"nx\">command</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">PutObjectCommand</span><span class=\"p\">({</span> <span class=\"na\">Bucket</span><span class=\"p\">:</span> <span class=\"nx\">bucket</span><span class=\"p\">,</span> <span class=\"na\">Key</span><span class=\"p\">:</span> <span class=\"nx\">key</span> <span class=\"p\">});</span>  <span class=\"k\">return</span> <span class=\"nf\">getSignedUrl</span><span class=\"p\">(</span><span class=\"nx\">client</span><span class=\"p\">,</span> <span class=\"nx\">command</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"na\">expiresIn</span><span class=\"p\">:</span> <span class=\"mi\">360000</span> <span class=\"p\">});</span><span class=\"p\">};</span><span class=\"k\">export</span> <span class=\"kd\">const</span> <span class=\"nx\">handler</span> <span class=\"o\">=</span> <span class=\"k\">async </span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"nx\">context</span><span class=\"p\">,</span> <span class=\"nx\">callback</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"kd\">const</span> <span class=\"nx\">clientUrl</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nf\">createPresignedUrlWithClient</span><span class=\"p\">({</span>      <span class=\"na\">region</span><span class=\"p\">:</span> <span class=\"nx\">REGION</span><span class=\"p\">,</span>      <span class=\"na\">bucket</span><span class=\"p\">:</span> <span class=\"nx\">BUCKET</span><span class=\"p\">,</span>      <span class=\"na\">key</span><span class=\"p\">:</span> <span class=\"nf\">randomUUID</span><span class=\"p\">(),</span>  \t<span class=\"p\">});</span>        <span class=\"k\">return</span> <span class=\"p\">{</span>      <span class=\"na\">result</span><span class=\"p\">:</span> <span class=\"dl\">\"</span><span class=\"s2\">SUCCESS</span><span class=\"dl\">\"</span><span class=\"p\">,</span>      <span class=\"na\">data</span><span class=\"p\">:</span> <span class=\"p\">[</span> <span class=\"nx\">clientUrl</span> <span class=\"p\">]</span>  \t<span class=\"p\">}</span>  <span class=\"p\">}</span><span class=\"p\">};</span></code></pre></div></div><p>업로드용 PresignedURI 의 경우, 방안4 에 나온 구조에서 보듯이 API Gateway 로 요청이 온 후 연결된 Lambda 함수에서 응답해야 하기 때문에 생성된 presignedUri 를 리턴하고 있다.</p><h3 id=\"api-gateway\">API Gateway</h3><p>이제 PresignedURI 만드는 람다함수를 API 로 노출시키기 위해 먼저 API Gateway를 만들어야 한다.</p><p>API Gateway 생성HTTP API 선택<img src=\"https://velog.velcdn.com/images/kmss6905/post/8720a760-672f-406d-96f8-142b14060b4c/image.png\" alt=\"\" /></p><p>이때 API Gateway가 Lambda 함수를 호출해야하기 때문에, 아까 만든 Lambda 함수를 지정한다.<img src=\"https://velog.velcdn.com/images/kmss6905/post/6af2f1af-ed04-485e-a132-796eea77994d/image.png\" alt=\"\" /></p><p>다음버튼을 눌러 계속 진행한다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/ba8f6638-5da9-4c65-b175-7cfe780e6974/image.png\" alt=\"\" />여기서 API Gateway의 메서드와 경로를 구성할 수 있다. 물론 만들고 나서 수정해도 상관없다. 나는 “GET /image/presigned-uri” 으로 경로를 설정했다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/6ff57e71-e3d7-4fe1-b3a9-a66de61d4e76/image.png\" alt=\"\" /></p><p>마지막으로 스테이지까를 정의한다. 이는 말그대로 스테이지 환경을 정의할 수 있으며 API 스테이지는 API ID 및 스테이지 이름으로 식별되며, API를 호출하는 데 사용되는 URL에 포함됩니다.</p><p>HTTP URI에 스테이지 변수를 사용하여 구성하는 자세한 사용법은 https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/http-api-stages.html 에 있으니 참고바란다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/3de90052-9fde-40b1-b480-01b40cfde42f/image.png\" alt=\"\" />새롭게 생성한 API를 볼 수 있다. 좀 전에 dev 라는 이름의 스테이지 이름을 사용하는 스테이지의 경우에는 현재 자동배포되지 않기 때문에 만약 dev 스테이지에도 배포를 원한다면 우측 상단에 있는 배포 버튼을 클릭하여 배포를 진행하면 된다.</p><p>이제 아래의 경로로 API 호출을 하면https://{app_id}.execute-api.ap-northeast-2.amazonaws.com/image/presigned-uri</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/5af90a8a-ec1f-4ad3-9daa-9247135ccd62/image.png\" alt=\"\" /></p><p>Presigned URI 를 받는 것을 알 수 있다.</p><h3 id=\"번외-api-gateway-사용자-지정-도메인-설정하기\">번외, API Gateway 사용자 지정 도메인 설정하기</h3><p>AWS 에서 제공하는 URI 주소 말고 사용자 지정 도메인 이름을 지정할 수 있다.</p><p>현재 itthatcat.xyz 도메인을 가비아 네임서버에 등록해놓은 상태이고 와일드 카드 인증서를 LetsEncrypted 를 통해 무료로 발급한 상태이다.</p><p>이제 img.itthatcat.xyz 의 새로운 서브도메인을 설정해보자.https://{app_id}.execute-api.ap-northeast-2.amazonaws.com/image/presigned-uri 로 호출하는 것이 아닌https://img.itthatcat.xyz/image/presigned-uri 로 호출할 수 있도록 하자</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/a9232828-2798-4a3b-96f3-f8a25644cf16/image.png\" alt=\"\" /></p><p>도메인 이름에는 사용하고자 하는 도메인 이름을 입력한다. (당연히 사용하고자 하는 도메인에 대해서 구입이 완료되어야 한다.)그리고 해당 도메인에 대해 발급한 인증서가 필요하다.</p><h4 id=\"사용하려고-하는-도메인에-acm-ssl-인증서-발급받기-with-aws가-아닌-다른-네임서버-사용중\">사용하려고 하는 도메인에 ACM SSL 인증서 발급받기 with AWS가 아닌 다른 네임서버 사용중</h4><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/b8530417-8bd5-45a2-ab68-f65d8b0bfac3/image.png\" alt=\"\" /></p><p>인증서의 경우 이미 만든 인증서를 가져와서 사용해도 좋지만, 나는 해당 도메인에 대해서는 새롭게 SSL 인증서를 만들기로 했다. 인증서가 여러개로 분산되어 관리의 포인트가 늘어난 다는 단점이 있지만, AWS ACM에서 만든 인증서의 경우 인증서의 갱신을 자동화할 수 있고 무료이다. 물론 원한다면 외부에서 사용된 인증서를 가져와서 사용할 수 있다. 다만 외부의 인증서의 경우 만료되었을 경우 갱신에 대한 로직은 대신해주지 않는다.<img src=\"https://velog.velcdn.com/images/kmss6905/post/3f3e7209-5812-432f-9911-68567fcabb32/image.png\" alt=\"\" /><img src=\"https://velog.velcdn.com/images/kmss6905/post/2b10859e-4163-40a9-a015-fcaf4f7daf4a/image.png\" alt=\"\" /><img src=\"https://velog.velcdn.com/images/kmss6905/post/96c9f5e4-61a9-4753-810c-85f1404c4667/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/9e559799-443f-4c9f-a016-3acfb5a76bc0/image.png\" alt=\"\" /></p><p>이제 네임 서버에 CNAME 레코드를 만들면 된다. 이를 통해 DNS 검증을 받는 것이다.</p><p>이때 CNAME 레코드 등록시 호스트에는 _21jkddfu2j.img.itthatcat.xyz. 에서 호스트 이름인 _21jkddfu2j.img 까지만 입력해야한다. 그 외는 그대로 입력한다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/f453b237-a6c3-4daa-b9f3-6471e7ae87f8/image.png\" alt=\"\" /></p><p>만약 서브도메인이 아닌경우라면_21jkddfu2j.itthatcat.xyz. 요렇게 될것이다. 그리고 CNAME 레코드 호스트는 _21jkddfu2j 입력하면 된다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/737faa86-0b53-4f58-b85f-5aacd5288ad2/image.png\" alt=\"\" />어느 정도 시간이 지나면 이렇게 “검증 대기중”에서 “발급” 상태로 바뀐 것을 알 수있다.(CNAME 레코드를 추가하고 10분 내로 발급되었다)</p><h4 id=\"사용자지정-도메인-등록하기\">사용자지정 도메인 등록하기</h4><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/d8a9553f-3e64-4bc4-9c0b-b3c2fd0ac836/image.png\" alt=\"\" /></p><p>사용하려고 하는 도메인 이름과 발급받은 ACM 인증서를 등록합니다.</p><h4 id=\"사용자-지정-도메인와-api-gateway-매핑하기\">사용자 지정 도메인와 API Gateway 매핑하기</h4><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/30042006-107c-4c1f-9ec7-04a489474dd3/image.png\" alt=\"\" />이렇게 사용자 지정 도메인에 대해 새로운 API Gateway 도메인 이름이 생겼다.이제 다시 가비아로 돌아와서 DNS 레코드를 추가해야한다. CNAME 레코드를 추가하여 img.itthatcat.xyz 로 접속했을 때 위의 가려진 도메인으로 이동할 수 있도록 해야한다.<img src=\"https://velog.velcdn.com/images/kmss6905/post/335b9fab-2683-42da-80ec-30db8a26c71a/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/a55aad24-b12c-4d93-a321-ae55a0e7949e/image.png\" alt=\"\" /></p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/3df73ed4-3727-46a0-bbda-03a9709f7cad/image.png\" alt=\"\" /></p><p>매핑하려고 하는 API 를 선택한다.</p><p>이제 <code class=\"language-html highlighter-rouge\">https://img.itthatcat.xyz/image/presigned-uri</code> 로 요청해보자.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/d970e2c1-7162-44db-9cc8-93065eeb9f67/image.png\" alt=\"\" /></p><p>정상적으로 데이터가 잘 나오는 것을 알 수 있다.</p><h4 id=\"번외\">번외</h4><p>현재는 API Gateway 앞단에 Cloudfront 를 구성한 후 Cloudfront -&gt; API Gateway -&gt; Lambda 로 호출하도록 구성한 상태이다.Cloudfront 역시 API Gateway 와 마찬가지로 AWS 에서 제공하는 도메인 이름이 아닌 새롭게 커스텀 도메인을 사용할 수 있으며 SSL 인증서 적용하는 방식도 같다.</p><hr /><h3 id=\"참고\">참고</h3><p>https://obviy.us/blog/sharp-heic-on-aws-lambda/https://docs.aws.amazon.com/ko_kr/acm/latest/userguide/troubleshooting-DNS-validation.html</p>",
            "url": "http://localhost:4000/2024/02/21/lamda-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-%EC%A0%81%EC%9A%A9%EA%B8%B0",
            
            
            
            "tags": ["aws","lambda","s3","api gateway","serverless","image resizing","presigned url"],
            
            "date_published": "2024-02-21T00:00:00+09:00",
            "date_modified": "2024-02-21T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/01/07/java-%EC%9D%98-final-%EC%9D%80-%EC%96%B4%EB%94%94%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C",
            "title": "Java의 final은 어디에 사용할 수 있을까?",
            "summary": "자바의 final 키워드는 클래스, 메서드, 변수에 사용하여 재할당을 막을 수 있습니다. 이 글에서는 final의 다양한 사용법과 주의할 점을 예제와 함께 자세히 알아봅니다.",
            "content_text": "Java final 키워드 완벽 정복  예제에서 사용한 모든 코드는 Github Repository 에 있습니다.final 키워드는 주로 변경 불가능한 전역 변수를 선언하거나 생성자의 파라미터로 받을 때 사용됩니다. 하지만 final은 이보다 더 다양한 곳에서 활용될 수 있습니다. 이 글에서는 final 키워드의 다양한 사용법을 자세히 알아보고, 예제를 통해 실제 활용 방법을 살펴봅니다.final 키워드 사용법final 키워드는 크게 클래스, 메서드, 변수 세 가지 대상에 사용할 수 있습니다.1. final 클래스: 상속을 막는 마지막 보루클래스에 final 키워드를 사용하면 해당 클래스는 더 이상 상속할 수 없습니다. 이는 클래스의 확장을 원하지 않을 때 유용하게 사용됩니다.public final class Cat {    private int weight;    // standard getter and setter}public class BlackCat extends Cat { // 컴파일 에러!}주의할 점: final 클래스가 불변(immutable) 객체를 의미하는 것은 아닙니다. 클래스 내부의 멤버 변수는 얼마든지 변경될 수 있습니다.class ClassFinalMainTest {    @Test    @DisplayName(\"final 클래스의 맴버변수는 바꿀 수 있다.\")    void mainTest() {        Money money = new Money();        money.setValue(100);        assertEquals(100, money.getValue());        assertDoesNotThrow(() -&gt; money.setValue(200)); // 예외발생하지 않음.        assertEquals(200, money.getValue());    }    final class Money {        private int value;        public void setValue(int value) {            this.value = value;        }        public int getValue() {            return value;        }    }}  Tip: IntelliJ IDEA에서는 final 클래스에 “압정” 아이콘을 표시하여 상속할 수 없음을 시각적으로 알려줍니다.  2. final 메서드: 오버라이딩 금지메서드에 final 키워드를 사용하면 해당 메서드는 하위 클래스에서 오버라이딩(재정의)할 수 없습니다.// 부모 클래스public class Cat {    public void meow() {        System.out.println(\"누구나 야옹~\");    }    final public void finalMeow() {        System.out.println(\"나만 야옹~\");    }    private void privateMeow() {        System.out.println(\"내부 야옹~\");    }}// 자식 클래스public class WhiteCat extends Cat {    @Override    public void meow() {        System.out.println(\"흰 고양이 야옹\");    }    // finalMeow() 메서드를 오버라이딩 하려고 하면 컴파일 에러 발생!    // @Override    // public void finalMeow() { ... }}만약 자식 클래스에서 부모의 final 메서드를 재정의하려고 하면 'finalMeow()' cannot override 'finalMeow()' in 'Cat'; overridden method is final 와 같은 컴파일 에러가 발생합니다.3. final 변수: 재할당은 이제 그만변수에 final 키워드를 사용하면 한 번만 값을 할당할 수 있으며, 이후에는 값을 변경할 수 없습니다.3.1. 원시 변수 (Primitive Variables)final로 선언된 원시 변수는 초기화 이후 다른 값을 할당할 수 없습니다.final int i = 1;i = 2; // 컴파일 에러!3.2. 참조 변수 (Reference Variables)final로 선언된 참조 변수는 다른 객체를 참조하도록 변경할 수 없습니다.final User user = new User(\"jimin\");user = new User(\"junguk\"); // 컴파일 에러!중요: 참조 변수 자체가 다른 객체를 가리키도록 변경할 수는 없지만, 참조하고 있는 객체의 내부 상태(멤버 변수)는 변경 가능합니다.final class XXXclass {    private int a = 5;}final XXXClass xxxClass = new XXXClass();xxxClass.a = 10; // 수정 가능!3.3. 필드 (Fields)final은 클래스의 필드에도 사용할 수 있습니다. 주로 상수(constant)를 정의하거나, 생성자에서 초기화되는 멤버 변수에 사용됩니다.상수 필드:class Point {    private static final double GLOBAL_POINT = 10.0;    public void changePointToTenDotOne() {        // GLOBAL_POINT = 10.1; // 컴파일 에러!    }}생성자 멤버 변수:final로 선언된 멤버 변수는 생성자 내에서 반드시 초기화되어야 합니다. 이는 객체의 불변성을 보장하고, NullPointerException과 같은 실수를 방지하는 데 도움을 줍니다.public class OrderService {    private final ProductRepository productRepository; // final 키워드 추가    public OrderService(ProductRepository productRepository) {        this.productRepository = productRepository; // 생성자에서 반드시 초기화    }    public void order(int id) {        Product product = productRepository.findId(id);        // etc    }}만약 final 멤버 변수를 생성자에서 초기화하지 않으면, 컴파일 에러가 발생하여 실수를 미리 방지할 수 있습니다.3.4. 메서드 인자 (Argument Variables)메서드의 인자에 final 키워드를 사용하면, 메서드 내부에서 해당 인자의 값을 변경할 수 없습니다.public int plus(final int a, final int b) {    // a += b; // 컴파일 에러!    int c = a + b;    return c;}요약Java의 final 키워드는 클래스, 메서드, 변수에 사용하여 재할당을 방지하는 역할을 합니다.  final 클래스: 상속 불가  final 메서드: 오버라이딩 불가  final 변수: 재할당 불가특히 생성자의 멤버 변수에 final을 사용하면, 객체 생성 시점에 해당 변수가 반드시 초기화되도록 강제하여 코드의 안정성을 높일 수 있습니다. final 키워드를 적재적소에 활용하여 더 견고하고 예측 가능한 코드를 작성해 보세요.참조  Baeldung - The final Keyword in Java",
            "content_html": "<h1 id=\"java-final-키워드-완벽-정복\">Java <code class=\"language-html highlighter-rouge\">final</code> 키워드 완벽 정복</h1><blockquote>  <p>예제에서 사용한 모든 코드는 <a href=\"https://github.com/kmss6905/blog/tree/main/_20240107\">Github Repository</a> 에 있습니다.</p></blockquote><p><code class=\"language-html highlighter-rouge\">final</code> 키워드는 주로 변경 불가능한 전역 변수를 선언하거나 생성자의 파라미터로 받을 때 사용됩니다. 하지만 <code class=\"language-html highlighter-rouge\">final</code>은 이보다 더 다양한 곳에서 활용될 수 있습니다. 이 글에서는 <code class=\"language-html highlighter-rouge\">final</code> 키워드의 다양한 사용법을 자세히 알아보고, 예제를 통해 실제 활용 방법을 살펴봅니다.</p><h2 id=\"final-키워드-사용법\"><code class=\"language-html highlighter-rouge\">final</code> 키워드 사용법</h2><p><code class=\"language-html highlighter-rouge\">final</code> 키워드는 크게 <strong>클래스</strong>, <strong>메서드</strong>, <strong>변수</strong> 세 가지 대상에 사용할 수 있습니다.</p><h3 id=\"1-final-클래스-상속을-막는-마지막-보루\">1. <code class=\"language-html highlighter-rouge\">final</code> 클래스: 상속을 막는 마지막 보루</h3><p>클래스에 <code class=\"language-html highlighter-rouge\">final</code> 키워드를 사용하면 해당 클래스는 더 이상 상속할 수 없습니다. 이는 클래스의 확장을 원하지 않을 때 유용하게 사용됩니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">Cat</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">weight</span><span class=\"o\">;</span>    <span class=\"c1\">// standard getter and setter</span><span class=\"o\">}</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BlackCat</span> <span class=\"kd\">extends</span> <span class=\"nc\">Cat</span> <span class=\"o\">{</span> <span class=\"c1\">// 컴파일 에러!</span><span class=\"o\">}</span></code></pre></div></div><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/f64a3029-421e-4add-b1b8-1427671ce17e/image.png\" alt=\"final 클래스 상속 불가\" /></p><p><strong>주의할 점:</strong> <code class=\"language-html highlighter-rouge\">final</code> 클래스가 불변(immutable) 객체를 의미하는 것은 아닙니다. 클래스 내부의 멤버 변수는 얼마든지 변경될 수 있습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">class</span> <span class=\"nc\">ClassFinalMainTest</span> <span class=\"o\">{</span>    <span class=\"nd\">@Test</span>    <span class=\"nd\">@DisplayName</span><span class=\"o\">(</span><span class=\"s\">\"final 클래스의 맴버변수는 바꿀 수 있다.\"</span><span class=\"o\">)</span>    <span class=\"kt\">void</span> <span class=\"nf\">mainTest</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"nc\">Money</span> <span class=\"n\">money</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Money</span><span class=\"o\">();</span>        <span class=\"n\">money</span><span class=\"o\">.</span><span class=\"na\">setValue</span><span class=\"o\">(</span><span class=\"mi\">100</span><span class=\"o\">);</span>        <span class=\"n\">assertEquals</span><span class=\"o\">(</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">money</span><span class=\"o\">.</span><span class=\"na\">getValue</span><span class=\"o\">());</span>        <span class=\"n\">assertDoesNotThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">money</span><span class=\"o\">.</span><span class=\"na\">setValue</span><span class=\"o\">(</span><span class=\"mi\">200</span><span class=\"o\">));</span> <span class=\"c1\">// 예외발생하지 않음.</span>        <span class=\"n\">assertEquals</span><span class=\"o\">(</span><span class=\"mi\">200</span><span class=\"o\">,</span> <span class=\"n\">money</span><span class=\"o\">.</span><span class=\"na\">getValue</span><span class=\"o\">());</span>    <span class=\"o\">}</span>    <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">Money</span> <span class=\"o\">{</span>        <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">;</span>        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setValue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getValue</span><span class=\"o\">()</span> <span class=\"o\">{</span>            <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/8e6d87d9-fa5f-4015-9a64-751f5f184dc7/image.png\" alt=\"final 클래스 테스트 결과\" /></p><blockquote>  <p><strong>Tip:</strong> IntelliJ IDEA에서는 <code class=\"language-html highlighter-rouge\">final</code> 클래스에 “압정” 아이콘을 표시하여 상속할 수 없음을 시각적으로 알려줍니다.</p>  <p><img src=\"https://velog.velcdn.com/images/kmss6905/post/83e18ef2-ee70-4c65-af5a-07c36acbf096/image.png\" alt=\"IntelliJ final 클래스 표시\" /></p></blockquote><h3 id=\"2-final-메서드-오버라이딩-금지\">2. <code class=\"language-html highlighter-rouge\">final</code> 메서드: 오버라이딩 금지</h3><p>메서드에 <code class=\"language-html highlighter-rouge\">final</code> 키워드를 사용하면 해당 메서드는 하위 클래스에서 오버라이딩(재정의)할 수 없습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"c1\">// 부모 클래스</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Cat</span> <span class=\"o\">{</span>    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">meow</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"누구나 야옹~\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"kd\">final</span> <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">finalMeow</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"나만 야옹~\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">privateMeow</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"내부 야옹~\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"c1\">// 자식 클래스</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">WhiteCat</span> <span class=\"kd\">extends</span> <span class=\"nc\">Cat</span> <span class=\"o\">{</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">meow</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"흰 고양이 야옹\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"c1\">// finalMeow() 메서드를 오버라이딩 하려고 하면 컴파일 에러 발생!</span>    <span class=\"c1\">// @Override</span>    <span class=\"c1\">// public void finalMeow() { ... }</span><span class=\"o\">}</span></code></pre></div></div><p>만약 자식 클래스에서 부모의 <code class=\"language-html highlighter-rouge\">final</code> 메서드를 재정의하려고 하면 <code class=\"language-html highlighter-rouge\">'finalMeow()' cannot override 'finalMeow()' in 'Cat'; overridden method is final</code> 와 같은 컴파일 에러가 발생합니다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/b3686362-1048-4d20-a745-d13bd812a7a7/image.png\" alt=\"final 메서드 오버라이딩 불가\" /></p><h3 id=\"3-final-변수-재할당은-이제-그만\">3. <code class=\"language-html highlighter-rouge\">final</code> 변수: 재할당은 이제 그만</h3><p>변수에 <code class=\"language-html highlighter-rouge\">final</code> 키워드를 사용하면 <strong>한 번만 값을 할당</strong>할 수 있으며, 이후에는 값을 변경할 수 없습니다.</p><h4 id=\"31-원시-변수-primitive-variables\">3.1. 원시 변수 (Primitive Variables)</h4><p><code class=\"language-html highlighter-rouge\">final</code>로 선언된 원시 변수는 초기화 이후 다른 값을 할당할 수 없습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"o\">;</span> <span class=\"c1\">// 컴파일 에러!</span></code></pre></div></div><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/2317ff3d-d4a3-4ade-8361-fdd4b990c068/image.png\" alt=\"final 원시 변수 재할당 불가\" /></p><h4 id=\"32-참조-변수-reference-variables\">3.2. 참조 변수 (Reference Variables)</h4><p><code class=\"language-html highlighter-rouge\">final</code>로 선언된 참조 변수는 다른 객체를 참조하도록 변경할 수 없습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">final</span> <span class=\"nc\">User</span> <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">User</span><span class=\"o\">(</span><span class=\"s\">\"jimin\"</span><span class=\"o\">);</span><span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">User</span><span class=\"o\">(</span><span class=\"s\">\"junguk\"</span><span class=\"o\">);</span> <span class=\"c1\">// 컴파일 에러!</span></code></pre></div></div><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/19979a37-0fa3-470d-87b9-57d5d877ebfd/image.png\" alt=\"final 참조 변수 재할당 불가\" /></p><p><strong>중요:</strong> 참조 변수 자체가 다른 객체를 가리키도록 변경할 수는 없지만, 참조하고 있는 <strong>객체의 내부 상태(멤버 변수)는 변경 가능</strong>합니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">XXXclass</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"kd\">final</span> <span class=\"nc\">XXXClass</span> <span class=\"n\">xxxClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">XXXClass</span><span class=\"o\">();</span><span class=\"n\">xxxClass</span><span class=\"o\">.</span><span class=\"na\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"o\">;</span> <span class=\"c1\">// 수정 가능!</span></code></pre></div></div><h4 id=\"33-필드-fields\">3.3. 필드 (Fields)</h4><p><code class=\"language-html highlighter-rouge\">final</code>은 클래스의 필드에도 사용할 수 있습니다. 주로 상수(constant)를 정의하거나, 생성자에서 초기화되는 멤버 변수에 사용됩니다.</p><p><strong>상수 필드:</strong></p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">class</span> <span class=\"nc\">Point</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">double</span> <span class=\"no\">GLOBAL_POINT</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">changePointToTenDotOne</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"c1\">// GLOBAL_POINT = 10.1; // 컴파일 에러!</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/776c5300-0757-485a-81b6-0ab61176fdc8/image.png\" alt=\"final 상수 필드 재할당 불가\" /></p><p><strong>생성자 멤버 변수:</strong></p><p><code class=\"language-html highlighter-rouge\">final</code>로 선언된 멤버 변수는 생성자 내에서 반드시 초기화되어야 합니다. 이는 객체의 불변성을 보장하고, <code class=\"language-html highlighter-rouge\">NullPointerException</code>과 같은 실수를 방지하는 데 도움을 줍니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">OrderService</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">ProductRepository</span> <span class=\"n\">productRepository</span><span class=\"o\">;</span> <span class=\"c1\">// final 키워드 추가</span>    <span class=\"kd\">public</span> <span class=\"nf\">OrderService</span><span class=\"o\">(</span><span class=\"nc\">ProductRepository</span> <span class=\"n\">productRepository</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">productRepository</span> <span class=\"o\">=</span> <span class=\"n\">productRepository</span><span class=\"o\">;</span> <span class=\"c1\">// 생성자에서 반드시 초기화</span>    <span class=\"o\">}</span>    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">order</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"nc\">Product</span> <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"n\">productRepository</span><span class=\"o\">.</span><span class=\"na\">findId</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">);</span>        <span class=\"c1\">// etc</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>만약 <code class=\"language-html highlighter-rouge\">final</code> 멤버 변수를 생성자에서 초기화하지 않으면, 컴파일 에러가 발생하여 실수를 미리 방지할 수 있습니다.</p><p><img src=\"https://velog.velcdn.com/images/kmss6905/post/d9b47b0f-1888-4624-869b-4b3c51f67244/image.png\" alt=\"final 멤버 변수 초기화 강제\" /></p><h4 id=\"34-메서드-인자-argument-variables\">3.4. 메서드 인자 (Argument Variables)</h4><p>메서드의 인자에 <code class=\"language-html highlighter-rouge\">final</code> 키워드를 사용하면, 메서드 내부에서 해당 인자의 값을 변경할 수 없습니다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"syntax\"><code><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">plus</span><span class=\"o\">(</span><span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// a += b; // 컴파일 에러!</span>    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"o\">;</span>    <span class=\"k\">return</span> <span class=\"n\">c</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><h2 id=\"요약\">요약</h2><p>Java의 <code class=\"language-html highlighter-rouge\">final</code> 키워드는 <strong>클래스, 메서드, 변수</strong>에 사용하여 <strong>재할당을 방지</strong>하는 역할을 합니다.</p><ul>  <li><strong><code class=\"language-html highlighter-rouge\">final</code> 클래스:</strong> 상속 불가</li>  <li><strong><code class=\"language-html highlighter-rouge\">final</code> 메서드:</strong> 오버라이딩 불가</li>  <li><strong><code class=\"language-html highlighter-rouge\">final</code> 변수:</strong> 재할당 불가</li></ul><p>특히 생성자의 멤버 변수에 <code class=\"language-html highlighter-rouge\">final</code>을 사용하면, 객체 생성 시점에 해당 변수가 반드시 초기화되도록 강제하여 코드의 안정성을 높일 수 있습니다. <code class=\"language-html highlighter-rouge\">final</code> 키워드를 적재적소에 활용하여 더 견고하고 예측 가능한 코드를 작성해 보세요.</p><hr /><h3 id=\"참조\">참조</h3><ul>  <li><a href=\"https://www.baeldung.com/java-final\">Baeldung - The final Keyword in Java</a></li></ul>",
            "url": "http://localhost:4000/2024/01/07/java-%EC%9D%98-final-%EC%9D%80-%EC%96%B4%EB%94%94%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C",
            
            
            
            "tags": ["java","final","불변성","immutable"],
            
            "date_published": "2024-01-07T00:00:00+09:00",
            "date_modified": "2024-01-07T00:00:00+09:00",
            
                "author":  {
                "name": "김민식",
                "url": "https://minshikkim.com",
                "avatar": null
                }
                
            
        }
    
    ]
}