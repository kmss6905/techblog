<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="기초가 탄탄한 자바 개발자가 되기 위해 알아야할 테스트 대역 (Test Double)" /><meta name="author" content="Colin Holzman" /><meta property="og:locale" content="en_US" /><meta name="description" content="자바 개발자를 위한 테스트 대역(Test Double)에 대한 글에서는 TDD 스타일로 코드 작성 시 의존성과 하위 시스템으로부터 격리하는 방법을 설명합니다. 테스트 대역의 네 가지 종류인 더미, 스텁, 페이크, 목 객체에 대해 각각의 정의와 사용 예제를 제공하며, 각 객체의 장점과 단점도 논의합니다. 특히, 목 객체의 경우 행동 검증을 통해 테스트의 신뢰성을 높일 수 있지만, 과도한 사용은 오히려 테스트를 깨지기 쉽게 만들 수 있음을 경고합니다. 이 글은 자바 개발자가 테스트를 효과적으로 수행하기 위한 기초 지식을 제공합니다." /><meta property="og:description" content="자바 개발자를 위한 테스트 대역(Test Double)에 대한 글에서는 TDD 스타일로 코드 작성 시 의존성과 하위 시스템으로부터 격리하는 방법을 설명합니다. 테스트 대역의 네 가지 종류인 더미, 스텁, 페이크, 목 객체에 대해 각각의 정의와 사용 예제를 제공하며, 각 객체의 장점과 단점도 논의합니다. 특히, 목 객체의 경우 행동 검증을 통해 테스트의 신뢰성을 높일 수 있지만, 과도한 사용은 오히려 테스트를 깨지기 쉽게 만들 수 있음을 경고합니다. 이 글은 자바 개발자가 테스트를 효과적으로 수행하기 위한 기초 지식을 제공합니다." /><link rel="canonical" href="http://localhost:4000/2023/12/05/java" /><meta property="og:url" content="http://localhost:4000/2023/12/05/java" /><meta property="og:site_name" content="김민식 기술블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-05T13:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="기초가 탄탄한 자바 개발자가 되기 위해 알아야할 테스트 대역 (Test Double)" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Colin Holzman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Colin Holzman"},"dateModified":"2023-12-05T13:00:00+09:00","datePublished":"2023-12-05T13:00:00+09:00","description":"자바 개발자를 위한 테스트 대역(Test Double)에 대한 글에서는 TDD 스타일로 코드 작성 시 의존성과 하위 시스템으로부터 격리하는 방법을 설명합니다. 테스트 대역의 네 가지 종류인 더미, 스텁, 페이크, 목 객체에 대해 각각의 정의와 사용 예제를 제공하며, 각 객체의 장점과 단점도 논의합니다. 특히, 목 객체의 경우 행동 검증을 통해 테스트의 신뢰성을 높일 수 있지만, 과도한 사용은 오히려 테스트를 깨지기 쉽게 만들 수 있음을 경고합니다. 이 글은 자바 개발자가 테스트를 효과적으로 수행하기 위한 기초 지식을 제공합니다.","headline":"기초가 탄탄한 자바 개발자가 되기 위해 알아야할 테스트 대역 (Test Double)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/12/05/java"},"url":"http://localhost:4000/2023/12/05/java"}</script><title> 기초가 탄탄한 자바 개발자가 되기 위해 알아야할 테스트 대역 (Test Double) - 김민식 기술블로그</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="김민식 기술블로그" href="/atom.xml"><link rel="alternate" type="application/json" title="김민식 기술블로그" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0}body{font-family:-apple-system,BlinkMacSystemFont,"avenir next",avenir,helvetica,"helvetica neue",ubuntu,roboto,noto,"segoe ui",arial,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none;padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:0 auto 2rem auto;padding:1rem}.title{margin:2rem auto 0 auto;max-width:60rem;padding-left:12rem;font-size:24px}.title a{text-decoration:none;font-weight:bold}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.section-nav{background-color:#fff;margin:5px 0;padding:10px 30px;border:1px solid #e8e8e8;border-radius:3px}figcaption{font-size:smaller}.pagination{margin-top:1.5rem;display:flex;align-items:center;gap:1rem;margin-left:auto}.pagination .page_number{margin-right:1rem}.pagination .page_number .current{font-weight:bold}.pagination img{width:24px;height:24px;display:block;padding:4px}.pagination img.disabled{opacity:.3}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-150864545-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-150864545-1'); </script></head><body><div class="title"> <a href="/">김민식 기술블로그</a></div><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Posts</a></li><li><a href="/about" >About</a></li><li><a href="/resume" >Resume</a></li><li><a href="/search" >Search</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>기초가 탄탄한 자바 개발자가 되기 위해 알아야할 테스트 대역 (Test Double)</h2><div class="toc"><ol id="toc" class="section-nav"><li class="toc-entry toc-h1"><a href="#20240107---java-java-의-final">2024.01.07 - [java] Java 의 final</a><ol><li class="toc-entry toc-h2"><a href="#클래스class">클래스(class)</a></li></ol></li></ol></div><div class="content"><h1 id="20240107---java-java-의-final">2024.01.07 - [java] Java 의 <code>final</code></h1><blockquote><p>예제에서 사용한 모든 코드는 <a href="https://github.com/kmss6905/blog/tree/main/_20240107">Github Repository</a> 에 있습니다.</p></blockquote><p>나는 변하지 않는 전역변수를 만들 때나 생성자의 파라미터를 받을 때 final 키워드를 사용했었다. 문득 final 에 대해 이것 말고 더 쓰이는 곳이 없을까? final에 대해 더 찾아보고 공부한 결과를 기록했다.</p><pre><code class="language-java">class A {
	// 변하지 않는 전역변수
	private static final INIT_VALUE = 0.1;
}
</code></pre><p>email 과 password 를 생성자 파라미터로 받는 Member 클래스의 모습이다.</p><pre><code class="language-java">// 생성자의 파라미터
public Member(final String email, final String password) {
        validateNonNull(email, password);
        this.email = email;
        this.password = password;
 }
</code></pre><p>우선 final 은 클래스, 메서드, 변수에 사용할 수 있다.</p><h2 id="클래스class">클래스(class)</h2><p>final 이 있는 클래스는 상속하여 사용할 수 없다.</p><pre><code class="language-java">public final class Cat {

    private int weight;

    // standard getter and setter
}

public class BlackCat extends Cat {

}
</code></pre><p>확장을 원하지 않는 경우에 해당 클래스에 final 키워드를 통해 다른 클래스가 상속받아 사용하는 것을 막을 수 있다.</p><p><img src="https://velog.velcdn.com/images/kmss6905/post/f64a3029-421e-4add-b1b8-1427671ce17e/image.png" width="70%" heightv="70%" /></p><p>단, 클래스에 final이 있다고 해서 final 클래스로 만든 객체가 불변하다는 것을 뜻하는 것은 아니다. 즉, 내부의 맴버변수는 얼마든지 바꿀 수 있다.</p><pre><code class="language-java">class ClassFinalMainTest {

    @Test
    @DisplayName("final 클래스의 맴버변수는 바꿀 수 있다.")
     void mainTest() {
        Moeny moeny = new Moeny();
        moeny.setValue(100);

        assertEquals(100, moeny.getValue());
        assertDoesNotThrow(() -&gt; moeny.setValue(200)); // 예외발생하지 않음.
        assertEquals(200, moeny.getValue());
    }

    final class Moeny {
        private int value;

        public void setValue(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    }
}
</code></pre><h align="center"> <img src="https://velog.velcdn.com/images/kmss6905/post/8e6d87d9-fa5f-4015-9a64-751f5f184dc7/image.png" width="40%" /> <h /> ![](https://velog.velcdn.com/images/kmss6905/post/83e18ef2-ee70-4c65-af5a-07c36acbf096/image.png) 참고로, 인텔리제이에서는 final 클래스의 경우 "압정표시"로 상속할 수 없다는 것을 표시해준다. ## 메서드(method) final 이 붙은 메서드는 오버라이딩 할 수 없다. 부모 클래스에 해당하는 Cat 클래스는 `public`, `private`, `final` 메서드로 각기 다른 "야옹~"을 출력하도록 했다. 자식 클래스에 해당하는 WhiteCat 가 오버라이딩 할 수 있는 메서드는 `public` 메서드 뿐이다. 이렇게 `public` 메서드의 경우 Cat 을 상속하여 오버라이딩을 통해 해당 `meow()` 메서드를 사용할 수 있다. ```java // 부모 클래스 public class Cat { private int weight; public void meow() { System.out.println("누구나 야옹~"); } final public void finalMeow() { System.out.println("나만 야옹~"); } private void privateMeow() { System.out.println("내부 야옹~"); } } // 자식 클래스 public class WhiteCat extends Cat{ @Override public void meow() { System.out.println("흰 고양이 야옹"); } } ``` 만약 자식클래스에서 부모의 final 메서드를 재정의 하려고 시도하면 어떻게 될까? `finalMeow()' cannot override 'finalMeow()' in 'Cat'; overridden method is final` ![](https://velog.velcdn.com/images/kmss6905/post/b3686362-1048-4d20-a745-d13bd812a7a7/image.png) 오버라이드한 메서드가 final 이기 때문에 오버라이드를 할 수 없다고 에러 메시지를 띄우고 있다. ## 변수(varibles) ### 1. 원시변수(Primitive Varibles) final 로 선언한 원시변수에 값을 할당한 후에는, 다른 값을 할당할 수 없다. ```java final int i = 1; int i = 2; ``` i 변수에 1을 할당한 후, 2를 재할당하려고 하면 아래와 같은 에러를 뿜어낸다. 이미 위에서 정의되었기 때문에 다시 재할당할 수 없다.! <h align="center"> <img src="https://velog.velcdn.com/images/kmss6905/post/2317ff3d-d4a3-4ade-8361-fdd4b990c068/image.png" width="50%" heigh="50%" /> </h> --- ### 2. 참조변수(Reference Varibles) ```java final User user = new User("jimin"); user = new User("junguk"); ``` <h align="center"><img src="https://velog.velcdn.com/images/kmss6905/post/19979a37-0fa3-470d-87b9-57d5d877ebfd/image.png" width="50%" heigh="50%" /></h> 원시변수의 경우와 마찬가지로 final 로 선언한 참조변수의 경우 역시 다른 참조변수의 할당이 불가능하다. 실수로 다른 변수 값으로 바꿔치기 되는 대참사를 막을 수 있다. 참고로 user 객체는 불변은 아니다. 즉, 재할당이 불가능한 거지 객체의 내부 변수 값은 바꿀 수 있다. 만약 final class 를 이용하여 객체를 생성할 때 해당 변수에 final을 선언하면 어떻게 될까? 위의 내용을 다시 정리하자면, 1. class 의 final 은 상속이 불가하다라는 것을 의미한다. 2. 참조변수의 final은 초기화 후 재할당 할 수 없는 것을 의미한다. 다시 한번 말하지만 해당 클래스 자체를 완전한 불변(immutable)으로 만드는 것은 아니다. 따라서 아래의 생성된 객체 내부의 변수(`a`)를 수정하는 건 가능하다. ``` final class XXXclass{ private int a = 5; } final XXXClass xxxClass = new XXXClass(); xxxClass.a = 10; // 수정이 가능하다!! ``` --- ### 3. 필드(Field) constant 상수 필드에 사용하거나, 생성자 맴버 변수에 final 을 사용할 수 있다. 이 경우 생성자가 완료되기 전에 모든 final 필드를 초기화해야 한다.(즉, 값을 할당해야한다) ```java class Point{ private static final GLOBAL_POINT = "10.0; public changePointToTenDotOne(){ this.GLOBAL_POINT = 10.1; // 이미 위에서 할당했기 떄문에 에러 발생!! } } ``` 위의 `GLOBAL_POINT` constant 변수는 final 키워드로 인해 재할당이 불가능한 변수가 되었다. `Point.GLOBAL_POINT = "10.1"` 로 값을 바꾸려고 시도한다면 컴파일 에러가 난다. ![](https://velog.velcdn.com/images/kmss6905/post/776c5300-0757-485a-81b6-0ab61176fdc8/image.png) 아래의 코드는 OrderService 가 ProductRepository 를 의존하고 있으며, 생성 시점에 ProductRepository 를 생성자 파라미터로 받아 초기화한다. 그리고 `void order(int id)` 의 경우 제품의 번호를 받아 productRepository 로 부터 상품을 조회하도록 한다. ```java public class OrderService { private ProductRepository productRepository; public OrderService(ProductRepository productRepository) { this.productRepository = productRepository; } public void order(int id) { Product product = productRepository.findId(id); // etc } } ``` 따라서 productRepository 는 null 이 되어선 안되고 반드시 초기화 `this.productRepostiroy = productRepostirot` 가 되어야한다. 만약 실수로 OrderService 생성 시점에 맴버변수 ProductRepository 를 초기화하는 코드를 깜빡 잊었다고 가정해보자. 아래와 같이 작성한다고 해서 컴파일 에러는 나지 않는다. ```java public class OrderService { private ProductRepository productRepository; public OrderService() { } public void order(int id) { Product product = productRepository.findId(id); // etc } } ``` 하지만 아래의 코드를 실행하면 ```java OrderService orderService = new OrderService(); orderService().order(1); ``` 초기화 되지 않은 ProductRepository 를 호출하려고 했기 때문에 `NullPointException` 예외가 터진다. ``` Exception in thread "main" java.lang.NullPointerException: Cannot invoke "variablesfinal.field.ProductRepository.findId(int)" because "this.productRepository" is null at variablesfinal.field.OrderService.order(OrderService.java:10) at variablesfinal.field.OrderMain.main(OrderMain.java:7) ``` 이때 final 키워드를 맴버 변수에 사용한다면 클래스 생성 시점에 강제로 final 키워드가 붙은 맴버변수를 초기화 할 수 있도록 강제할 수 있다. 따라서 최소한 맴버 변수 초기화 하는 것을 깜빡해 `NullPointException` 에러가 나는 것은 막을 수 있다. ![](https://velog.velcdn.com/images/kmss6905/post/d9b47b0f-1888-4624-869b-4b3c51f67244/image.png) 변수 'productRepository'가 초기화되지 않았을 수 있다고 경고를 보낸다. 따라서 강제로 초기화하여 사용할 수 밖에 없도록 만든다. ```java private final ProductRepostiroy productRepository; public OrderService(ProductRepository productRepository){ this.productRepository = productRepository; } ``` --- ### 4. 메서드 인자(Argument Varibles) 메서드의 인자에 final 키워드를 사용할 수 있다. 이 경우 받은 인자를 메서드 내부에서 재할당 하여 사용할 수 없다. ```java public int plus(final int a, final int b){ int a += b; return a; } ``` 메서드 인자 중 `a` 는 이미 final로 선언되었기 때문에 `a`에 다른 값을 재할당할 수 없다. final 메서드 인자에 새로운 값을 할당할 수 없기 때문에 새로운 변수를 선언하여 사용해야한다. ```java public int plus(final int a, final int b){ int c = a + b; return c; } ``` ## 요약 java 의 final 키워드는 클래스, 메서드, 메서드의 아규먼트, 필드(consant, member varibles) 에 사용가능하다. final 은 말그대로 최종이라는 뜻으로서 재할당을 막는 데 목표를 두고있다.그렇기 때문에 적절한 final 키워드를 사용해서 재할당을 하지 말도록 하는 의미를 들어내도록 사용할 수 있다. 특히, 생성자 맴버변수에 final을 사용하게 될 경우, 재할당 뿐만 아니라 생성자 초기화 시 무조건 할당해야 하도록 강제하는 역할을 하기도 한다. ### 참조 --- https://www.baeldung.com/java-final </h></div><span class="meta"><time datetime="2023-12-05T13:00:00+09:00">December 5, 2023</time> &middot; <a href="/tag/테스트">테스트</a>, <a href="/tag/테스팅">테스팅</a>, <a href="/tag/테스트 대역">테스트 대역</a>, <a href="/tag/Test Double">Test Double</a>, <a href="/tag/dummy">dummy</a>, <a href="/tag/stub">stub</a>, <a href="/tag/fake">fake</a>, <a href="/tag/mock">mock</a>, <a href="/tag/더미">더미</a>, <a href="/tag/스텁">스텁</a>, <a href="/tag/페이크">페이크</a>, <a href="/tag/목">목</a>, <a href="/tag/mocking">mocking</a></span> <script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script></section></main></body></html>
